#LyX 1.5.2 created this file. For more info see http://www.lyx.org/
\lyxformat 276
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage{usenix}
\end_preamble
\language english
\inputencoding latin1
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\paperfontsize 10
\spacing single
\papersize letterpaper
\use_geometry true
\use_amsmath 1
\use_esint 0
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\leftmargin 1in
\topmargin 1in
\rightmargin 1in
\bottommargin 1in
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 2
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Free Factories: Unified Infrastructure for Data Intensive Web Services
\end_layout

\begin_layout Author
Alexander Wait Zaranek, Tom Clegg, Ward Vandewege, George M.
 Church
\begin_inset ERT
status open

\begin_layout Standard


\backslash

\backslash

\end_layout

\end_inset

Harvard University 
\begin_inset ERT
status open

\begin_layout Standard


\backslash

\backslash

\end_layout

\end_inset

await@genetics.med.harvard.edu
\end_layout

\begin_layout Abstract
This paper introduces the Free Factory, a platform for deploying data-intensive
 web services using commodity hardware and free software.
 In a Free Factory, applications running on independently administered virtual
 machines, called Freegols, make use of shared batch processing and data
 storage facilities.
 The storage system exploits idle RAM and disk for cache while reserving
 whole disks for high bandwidth aggregate storage.
 The batch processing system uses a variation of the MapReduce model.
 Resources are allocated using a credit system which encourages high utilization
 and ultimately allows end users to pay for prioritized service.
 On first implementation, our sample image processing applications exceed
 1000 megabytes per second of combined disk I/O on our two 48-node systems.
 We estimate commodity clusters with our design -- costing $500,000 per
 year for staff, new hardware, and hosting -- can achieve 4000-8000 megabytes
 per second of disk I/O per cluster, and serve hundreds of simultaneous
 requests on multi-hundred terabyte data sets.
 At this price, a 50% cumulative utilization rate over two years is required
 to break even with the popular Amazon EC2 service.
 
\end_layout

\begin_layout Section
Introduction 
\end_layout

\begin_layout Standard
Data sets that seemed large ten or twenty years ago appear tiny today, and
 growth is expected to accelerate in the next twenty years 
\begin_inset LatexCommand cite
key "Bell2006,Szalay2006"

\end_inset

.
 Low-cost hardware offers plentiful CPU cycles and terabytes of disk space,
 but efficient and fault-tolerant utilization of this hardware is non-trivial
 for small organizations.
\end_layout

\begin_layout Standard
Real world performance depends on well-matched application, storage, batch
 processing, and hardware layers.
 How well these layers work together depends on usage patterns as well as
 the intrinsic properties of the individual subsystems.
 Our approach is to consider all of these factors together, in order to
 optimize total system performance.
\end_layout

\begin_layout Standard
We also aim to make economies of scale more accessible to smaller organizations.
 We recognize the need for independent user communities to share a common
 infrastructure, and contribute to the costs in proportion to the demands
 they make of the resources.
\end_layout

\begin_layout Standard
We have concentrated our efforts on small clusters with big disks, inexpensive
 CPUs and single rack unit nodes that can be serviced by one person.
 The aim is a balanced cluster in which the disk I/O bandwidth is matched
 by the network I/O bandwidth.
 We scale this design by building a virtual private network of clusters,
 connected over the Internet.
\end_layout

\begin_layout Standard
Using virtualization each cluster incorporates a number of application servers,
 which we call Free Golems or Freegols, each having access to data storage
 and batch processing facilities on remote clusters as well as its own.
 As clusters are retired and replaced, Freegols can be migrated to new clusters
 with minimal downtime for application users.
\end_layout

\begin_layout Standard
The use of virtualization permits us to consider a model with the following
 actors.
 
\begin_inset Quotes eld
\end_inset

Users
\begin_inset Quotes erd
\end_inset

 are interested in a web service and interact with it via a web browser.
 
\begin_inset Quotes eld
\end_inset

Freegols
\begin_inset Quotes erd
\end_inset

 are autonomous web service robots that provide web services by utilizing
 the resources of the clusters in the Free Factory.
 
\begin_inset Quotes eld
\end_inset

Administrators
\begin_inset Quotes erd
\end_inset

 are the application developers and scientists who maintain Freegols.
 
\begin_inset Quotes eld
\end_inset

Deputies
\begin_inset Quotes erd
\end_inset

 maintain the Free Factory infrastructure.
 A 
\begin_inset Quotes eld
\end_inset

trustee
\begin_inset Quotes erd
\end_inset

 sets policy and obtains funds to pay for staff, hardware, and hosting for
 a number of clusters.
 Freegols are non-human actors but they participate in a credit system --
 a fledgling virtual currency -- that we hope will allow administrators,
 deputies and trustees to pass on real dollar costs to users.
 Any entity with an account balance in this virtual currency is a 
\begin_inset Quotes eld
\end_inset

participant
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Others have explored the possibility of capturing market signals from users
 and we believe this is an attractive way to allocate resources for our
 applications in the long term 
\begin_inset LatexCommand cite
key "Dash2003,Shneidman2005,Brunelle2006"

\end_inset

.
 Since we have control of our architecture from the hardware up, we hope
 that implementation and experimentation with such mechanisms will be relatively
 straightforward.
 We have not focused on implementation here because we have not yet had
 acute resource contention problems.
\end_layout

\begin_layout Standard
The contribution of this paper is a unified platform for data intensive
 web services which we encourage others to implement and develop further.
 It makes efficient use of low-cost hardware in an environment where a variety
 of users and applications share storage and computation resources.
\end_layout

\begin_layout Section
Design and architecture 
\end_layout

\begin_layout Subsection
Commodity hardware, free software
\end_layout

\begin_layout Standard
When building an affordable, high-availability, data-intensive web service
 it is desirable to have control of the system's total cost of ownership.
 Part of our strategy is to avoid proprietary technologies in favour of
 free software, including the tools we develop ourselves.
 This way, we can build on existing tools and have confidence that we can
 replace or modify them when necessary.
\end_layout

\begin_layout Standard
When choosing hardware, we are interested in maximizing the usable disk,
 RAM, CPU, and network bandwidth per unit cost.
 At present dual gigabit ethernet, 1000-gigabyte SATA disks, and dual-socket
 quad core motherboards seem to best fit our needs.
 Full-bandwidth 48-port switches are also available at low cost.
 Therefore, the most affordable way to configure a large number of disks
 and CPUs is to build a network of 48-node clusters, interconnected by relativel
y slow network links or VPNs.
 We call such a network -- as depicted in Figure\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Network.2.1"

\end_inset

 -- a Free Factory .
 Our approach is to squeeze as much performance as possible out of this
 type of network.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename /home/awz/Desktop/diagram3.eps
	width 3in

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Within each cluster, total network bandwidth is close to total disk bandwidth.
 Bandwidth between clusters can be lower by several orders of magnitude.
\begin_inset LatexCommand label
name "fig:Network.2.1"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Given the limited size of each cluster, effective communication between
 clusters is integral to the design.
 This also comes with benefits.
 We expose the network topology to the applications so that they can make
 good decisions about where and when to perform computation, and where to
 store data, depending on the varying scarcity of these resources on different
 clusters.
 Each cluster is self-contained so there is no single point of failure in
 the entire network.
 The network can be maintained by a small team of deputies.
 It is feasible to deploy entire clusters at once, rather than performing
 incremental upgrades to a large cluster.
 Multiple clusters can be used to increase confidence in the repeatability
 of computational results, and to monitor the effects of different combinations
 of hardware, software, and usage patterns.
\end_layout

\begin_layout Standard
We believe excellent economies of scale can be achieved at a total annual
 cost of $500,000.
 We allocate half of this cost to salaries for deputies.
 The other half pays for annual hardware purchases and ongoing hosting costs.
 Each year, deputies deploy a new 48-node cluster with inexpensive CPUs
 and 192 1TB disks.
 Although our system tolerates failures -- especially disk failures -- manual
 intervention is expensive.
 Since disks have high failure rates independent of size 
\begin_inset LatexCommand cite
key "Bairavasundaram2007,Pinheiro2007,Elerath2007,Schroeder2007"

\end_inset

, we prefer larger disks.
 As the number of clusters grows, hosting costs increase.
 When the annual hosting cost surpasses the per-cluster hardware cost, the
 deputies start retiring old clusters as new clusters are purchased, thus
 stabilizing hosting costs.
 In the first few years, when hosting costs are low, the unused hosting
 budget can be set aside against future years.
\end_layout

\begin_layout Standard
This deployment strategy makes it possible to compare costs with a service
 like Amazon EC2 
\begin_inset LatexCommand cite
key "amazon2008"

\end_inset

.
 Amazon offers a 
\begin_inset Quotes eld
\end_inset

large instance
\begin_inset Quotes erd
\end_inset

 with two 1TB disks for $0.80/hr.
  One of our 48-node clusters has a capacity roughly equivalent to 96 of
 these large instances at $672,768 per year.
 Renting 96 large instances in the first year and 192 in the second year
 will cost $2,018,304.
 At 50% cumulative utilization, the Free Factory breaks even with the Amazon
 service in 2 years.
 It is highly likely that the assembled team of deputies and hardware will
 provide the trustee with value beyond the second year, so this seems to
 be an economical solution.
\end_layout

\begin_layout Subsection
Freegols and virtualization
\end_layout

\begin_layout Standard
There are a wide variety of languages, toolkits and methodologies for deploying
 scalable web services.
 One factor that contributes to Amazon EC2's popularity is that it permits
 web service administrators to choose their own tools.
 We found that giving users this freedom suited our environment.
\end_layout

\begin_layout Standard
Virtualization encourages a model wherein a larger number of administrators
 have 
\begin_inset Quotes eld
\end_inset

root
\begin_inset Quotes erd
\end_inset

 privileges on their own virtual application servers, or Freegols.
 Deputies -- who manage the hypervisors and other shared services on the
 clusters -- are the traditional system administrators who we consider to
 be the Free Factory's staff.
 The RAM, virtual processors, and network bandwidth of Freegols are shared
 with the storage and processing services.
 If necessary, an administrator can ensure that a Freegol does not share
 these resources with other Freegols by getting an allocation for all of
 the available CPU and RAM.
\end_layout

\begin_layout Standard
We use the term 
\begin_inset Quotes eld
\end_inset

warehouse
\begin_inset Quotes erd
\end_inset

 to refer to the shared computation and storage facilities offered on a
 cluster.
 A cluster of physical machines is used as a warehouse as well as a hosting
 facility for Freegols.
\end_layout

\begin_layout Standard
This model requires that the processing and storage interfaces incorporate
 authentication systems which view Freegols as responsible entities.
 Each Freegol has a private key for signing requests which consume significant
 cluster resources.
 For infrequent operations like scheduling new batch jobs, signatures are
 verified in real time.
 For write operations in long term storage, we can avoid the latency penalty
 by honoring the write, then collecting and verifying signatures later when
 resources permit.
 This is safe because the content-addressable storage system never needs
 to overwrite existing data.
 The only operation which needs to be authenticated in real time is the
 delete operation, which is never performed by Freegols directly.
\end_layout

\begin_layout Standard
It is often beneficial to implement services in virtual machines even though
 they may not need the warehouse services.
 Shared network services like web proxies, DNS caches, backup servers, and
 operating system mirror sites can be installed on virtual nodes which are
 maintained by deputies.
 The central control software for the warehouse itself can be installed
 on one or more virtual machines, as we have done.
 Some administrators may obtain Freegols for applications which have no
 use for the warehouse services but simply need a virtual node with root
 privileges.
 Providing independent virtual machines for various purposes is an effective
 way to maximize value per dollar invested in hardware, hosting and staff.
\end_layout

\begin_layout Standard
A user request to a Freegol and the subsequent cascade of events is shown
 in Figure 
\begin_inset LatexCommand ref
reference "fig:freegol2.2"

\end_inset

.
 The system permits hardware to be securely shared for multiple purposes.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename /home/awz/Desktop/diagram4.eps
	width 3in

\end_inset


\begin_inset Caption

\begin_layout Standard
Each physical node has a warehouse node which offers cache and storage services,
 and performs computation on behalf of Freegols as instructed by the controller.
 These same nodes can also support a number of Freegols and other virtual
 machines.
 Four physical nodes are depicted by the squares.
 
\begin_inset LatexCommand label
name "fig:freegol2.2"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Storage services 
\end_layout

\begin_layout Standard
The objectives of our storage system are to: (1) minimize I/O bottlenecks
 in order to make the best use of available CPU cycles; (2) provide a low-latenc
y cache with automatic garbage collection; (3) provide long term storage
 with high read and write throughput and provisions for usage accounting.
 The storage services must yield good performance when used directly from
 the Freegol, as well as from batch jobs.
 Inspired by the Google File System
\begin_inset LatexCommand cite
key "Ghemawat2003"

\end_inset

, Bigtable
\begin_inset LatexCommand cite
key "Chang2006"

\end_inset

 and the plethora of raw materials made possible by free and open source
 software, we felt we could build a system that suited our needs perfectly.
 
\end_layout

\begin_layout Standard
We implement a three-level content addressable storage system.
 We use Memcached as a low latency RAM cache.
 This is well suited to small strings (under one million bytes) and does
 not require a central controller.
 We use MogileFS to implement a disk cache.
 This gives good performance for block sizes up to 64 megabytes.
 For long term storage service we have developed our own server which minimizes
 the role of the central controller, while providing opportunities to charge
 users for priority service as well as disk space consumption.
\end_layout

\begin_layout Standard
Aggregate I/O bandwidth is limited by several factors.
 Our storage services are designed to minimize the effects of these factors.
\end_layout

\begin_layout Enumerate
Disk seeks have a disastrous effect on aggregate disk read and write bandwidth.
 We minimize thrashing by storing data in contiguous 64-megabyte chunks
 when possible.
 Our long term storage service ensures that only one disk operation happens
 at a time on a given disk; this minimizes seeks and therefore improves
 throughput in busy times.
\end_layout

\begin_layout Enumerate
A gigabit network interface can only handle 3-4 concurrent readers at full
 disk transfer rates.
 Ideally, network traffic is distributed evenly among all nodes in a cluster.
 We approximate this by using MD5 checksums to distribute data blocks uniformly
 across all nodes in the cluster.
\end_layout

\begin_layout Enumerate
Central controllers get bogged down when they try to handle too many concurrent
 clients.
 Peformance is best when most operations are completed without contacting
 a central controller.
 Our storage system can read and write blocks without involving the controller
 in real time.
 Our disk cache is indexed in RAM, so most reads do not involve the controller.
\end_layout

\begin_layout Enumerate
Writes are slow, especially when storing multiple copies of each block.
 When an identical copy of an output block already exists in the warehouse,
 our content-addressing approach allows the API to transparently skip unnecessar
y write operations.
\end_layout

\begin_layout Standard
All three storage systems use an MD5 addressing approach: the name of each
 block of data is the MD5 checksum of the data.
 This naming scheme provides several benefits.
\end_layout

\begin_layout Enumerate
The client API, when retrieving a block from any of the three storage systems,
 can compute the MD5 checksum of the data and compare it with the block
 name.
 If the checksum does not match, the API can fetch the data from a different
 host, a different storage system, or a remote warehouse.
 This verification process can be completely transparent to the application.
\end_layout

\begin_layout Enumerate
Multiple jobs often produce the same output.
 For example, a Freegol may re-run a job every time the job's source code
 is modified in the source repository, and every time an operating system
 upgrade is performed, to make sure the job still produces the same result.
 If the output is identical to the previous run, no additional storage space
 is consumed by the new job.
\end_layout

\begin_layout Enumerate
Freegols and concurrent batch jobs can share data without worrying about
 overwriting blocks at inopportune times.
\end_layout

\begin_layout Standard
Efficient use of our storage system requires that Freegols store data in
 64-megabyte blocks.
 However, the underlying data is likely to be arranged in much smaller logical
 units.
 To address this, we introduce a 
\begin_inset Quotes eld
\end_inset

manifest'' file format.
 In addition to increasing performance, the manifest format is a valuable
 tool for managing large data sets.
\end_layout

\begin_layout Standard
A manifest is a text file containing a set of filenames, arranged into streams.
 Each stream has a name, a set of files, and a list of the blocks that make
 up the file data.
 Each block is specified by its MD5 checksum, size, and concise information
 about the locations where the block is known to be stored.
 A manifest may itself be split into 64 megabyte blocks and stored in the
 warehouse, in which case its unique key -- the list of MD5 checksums of
 those blocks -- can be used to retrieve it.
\end_layout

\begin_layout Standard
Once a manifest is stored in the warehouse, it can be retrieved, or used
 as the input to a batch job, by any Freegol that knows its key.
 Also, each warehouse has a central database of manifest names.
 A Freegol can send a cryptographically signed request to the warehouse
 controller specifying a manifest key, the desired name, and--to avoid race
 conditions--the manifest key which was previously associated with the name.
 This atomic transaction has several effects.
\end_layout

\begin_layout Enumerate
Any Freegol can look up the name to retrieve the manifest key.
\end_layout

\begin_layout Enumerate
The manifest is considered to be valuable to the signer.
 If the manifest contains hashes indicating blocks in long term storage,
 the signer is willing to spend credits to protect those blocks from deletion.
\end_layout

\begin_layout Enumerate
The old manifest, if it is not associated with any other names, is no longer
 considered valuable; the data blocks mentioned in it may be deleted if
 they are not mentioned in any other named manifests.
 
\end_layout

\begin_layout Standard
Optionally, a Freegol may also specify a list of keys which have permission
 to overwrite this manifest name.
\end_layout

\begin_layout Subsection
Batch processing services 
\end_layout

\begin_layout Standard
The objectives of our computation system are to: (1) use as many as possible
 of the available CPU cycles on all machines; (2) allow jobs to easily be
 repeated many times on various clusters to check for bugs and inconsistencies;
 (3) handle occasional failures gracefully; (4) keep statistics about performanc
e and failure rates.
\end_layout

\begin_layout Standard
Batch processing is coordinated by a central controller.
 The controller accepts signed requests from Freegols to schedule new jobs.
 The controller decides when to start new jobs according to availability
 of resources and the number of credits offered by the requestor.
 The controller can be expected to occasionally cancel and reschedule an
 already-running job, or reduce its resource allocation, if it is outbid
 by a new job submission.
\end_layout

\begin_layout Standard
Freegols can retrieve a list of current, pending, and previous jobs from
 the controller.
 The controller provides specifications and statistics for each job, including
 inputs, outputs, start and finish times, and (for current jobs) how many
 more job steps remain in the queue.
 Freegols can poll the controller to determine the status of their own jobs,
 get hints about how busy the warehouse is, and find out about jobs that
 other Freegols have submitted.
\end_layout

\begin_layout Standard
The execution of the individual steps in a batch job is handled by a job
 manager process.
 The job manager supports a computation strategy similar to MapReduce 
\begin_inset LatexCommand cite
key "Dean2004"

\end_inset

.
 Each job stores some output in the warehouse, which gets assembled at the
 end of the job.
 Additionally, each job step has the ability to enqueue more job steps,
 and specify which job steps may be run in parallel.
\end_layout

\begin_layout Standard
The program that performs the work of a single job step is called a ``mr-functio
n''.
 Mr-functions are kept in a revision control system.
 Deputies and administrators can update existing mr-functions and create
 new ones, subject to access controls on the revision control repository.
 Once it is committed to the repository, a mr-function can be used in a
 job submission by any Freegol.
\end_layout

\begin_layout Standard
The most convenient way to construct an efficient batch job is to use a
 single manifest as input, and schedule one job step for each stream in
 the manifest.
  Each job step reads one full stream from the input manifest from start
 to finish, and writes one full stream in the output manifest.
 The warehouse API includes tools and examples to make it easy to write
 mr-functions that use this strategy.
\end_layout

\begin_layout Section
Implementation 
\end_layout

\begin_layout Subsection
Commodity hardware, free softwareÂ 
\end_layout

\begin_layout Standard
We are currently operating two clusters using a variety of off-the-shelf
 hardware, free software such as GNU/Linux and SLURM, and our own custom
 software which is also free.
\end_layout

\begin_layout Standard
We worked with Harvard University's Office of the General Counsel and Office
 of Technology Licensing to develop a suitable contract for our free software
 development work.
 The salient points of this contract are: monthly payments, permission to
 work remotely, permission to set hours, copyright assignment of work to
 Harvard, and assurances of confidentiality and non-disclosure.
 Furthermore, contracted work that is made public by Harvard University
 is released under the GNU General Public License (GNU GPL) for software
 and the GNU Free Documentation License (GNU FDL) for other textual works.
 As the copyright holder, Harvard University is also free to release the
 works under any other license.
 Our intent is to use similar contracts for occasional paid contributors
 and unpaid volunteers.
\end_layout

\begin_layout Standard
Our two clusters are located a few kilometers apart and connected by Harvard
 University's fiber optic network.
 ``Uncle'' is our experimental research cluster; ``Templeton'' is our production
 cluster.
 Our clusters are depicted in Figure\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:uncle_templeton_diag"

\end_inset

.
 Uncle is largely made up of 32-bit Intel Xeon machines, many of which are
 four years old.
 Templeton's hardware is more recent, and all machines have AMD Opteron
 64-bit processors.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename /home/awz/Desktop/networkdiagram.eps
	width 3in

\end_inset


\begin_inset Caption

\begin_layout Standard
On each cluster, some machines host warehouse nodes, Freegols, and other
 virtual machines; some are ``xenless'' nodes w hich act as dedicated warehouse
 nodes.
\begin_inset LatexCommand label
name "fig:uncle_templeton_diag"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Physically, each cluster consists of 48 1U multi-processor nodes.
 All newer nodes have four disk slots and the older nodes are diskless.
 Each newer node has two gigabit ethernet ports, which are connected to
 two 48-port gigabit switches.
 Two to four ``headnodes'' have a third ethernet port connected to the upstream
 switch, and optionally a fourth port connected to an out of band management
 network.
 The headnodes act as gateways to the internet and as VPN endpoints.
 Currently we reserve an entire physical machine for one of the headnodes
 (not shown), and run the other on a virtualized node running Xen.
 In the future we hope to run the firewall/VPN endpoint in a domU with a
 non-Xen kernel (for security reasons), which is possible with machines
 that support hardware virtualization.
\end_layout

\begin_layout Standard
Our VPN is a simple OpenVPN point-to-point setup, terminated on a headnode
 at each end.
 The VPN data rate reaches about 200 megabits per second.
 Throughput is limited by the processing speed of one endpoint which has
 one dual-core Opteron 265 CPU at 1.8GHz.
 The other endpoint has 2 single-core Opteron 250 processors at 2.4GHz; CPU
 load is considerably lower there.
\end_layout

\begin_layout Standard
Uncle currently runs the latest release of Ubuntu, while Templeton runs
 the latest ``long term support'' release of Ubuntu.
 We chose Ubuntu over Debian because of Ubuntu's 6 month release schedule,
 but we expect to build a Debian cluster in the future.
 Debian is philosophically closer to our ``free software only'' goal.
 In any case we aim to be distribution-agnostic.
\end_layout

\begin_layout Standard
We try to run recent kernels from kernel.org on non-virtualized machines.
 This has led to some significant performance increases compared to the
 standard distribution kernel.
 For instance, we have seen the performance of the tg3 network driver improve
 with the last few stable kernel releases (with the exception of the early
 2.6.23 releases, due to a bug).
\end_layout

\begin_layout Standard
The latest machines that we purchased came pre-installed with LinuxBIOS.
 LinuxBIOS is a free software BIOS that has a number of advantages over
 proprietary alternatives.
 All source code is open and available under the GPL.
 Serial console support is reliable.
 Boot time is much faster -- LinuxBIOS takes only a few seconds to bring
 the machine into a state where it can start booting the OS.
\end_layout

\begin_layout Standard
We use Opengear CM4148 console servers on each cluster for out-of-band access
 to the serial console of each server.
 The Opengear console servers are embedded linux machines for which the
 entire source code is available for download at opengearweb.org.
 The company provides instructions for modifying the firmware, and for building
 the firmware from source.
 We also use networked PDUs to allow remote power cycling of any device
 in the cluster via our out-of-band management network.
\end_layout

\begin_layout Subsection
Freegols and virtualization 
\end_layout

\begin_layout Standard
Some nodes are partitioned into virtual machines using Xen.
 This is illustrated in Figure\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:xen node"

\end_inset

.
  Each virtualized node has one virtual machine set up as a combined compute/sto
rage node.
 The remaining RAM and disk space is available for Freegols, and for virtual
 machines administered by deputies.
 
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename /home/awz/Desktop/diag disk partitions from jer.eps
	lyxscale 40
	width 3in

\end_inset


\begin_inset Caption

\begin_layout Standard
On a virtualized node with RAID-1, up to two disks can be dedicated to the
 warehouse's long-term storage system.
\begin_inset LatexCommand label
name "fig:xen node"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
System software and Freegols' local filesystems use RAID-1.
 Warehouse nodes leave redundancy up to the API: additional copies of data
 blocks, if needed, are stored on other nodes and other clusters.
 The long term storage server is able to control disk thrashing if it has
 exclusive use of each of its disks.
\end_layout

\begin_layout Standard
Administrators, and some of their users, have access to shell accounts on
 their Freegols.
 Our security model is largely perimeter-based at this point, because our
 users are relatively trustworthy.
 Specifically, each user can log in to an account on a shared virtual ``access''
 node, located on a headnode, using an SSH private key.
 The user is then automatically connected to the SSH server on her own Freegol
 by means of an ``nc'' command specified in her account's authorized_keys
 file.
\end_layout

\begin_layout Standard
One virtual machine acts as a reverse HTTP proxy.
 All HTTP and HTTPS traffic to the cluster is forwarded by the headnode
 to this server.
 The proxy forwards the request to the appropriate Freegol, which can be
 anywhere in the cluster, and returns the response to the client.
 After some optimization, this virtual server with moderate resources (four
 shared Opteron 265 cores and 1GB RAM) can process 1000 simultaneous requests,
 each returning 4.4 kilobytes of data, with TCP keepalive disabled, and have
 plenty of CPU power to spare.
 Other virtual machines include DNS caches and servers, an SMTP server for
 routing incoming mail, and a local Ubuntu mirror site.
 
\end_layout

\begin_layout Standard
The warehouse storage and processing services involve several databases
 and controller processes, which we run on a single virtual machine.
 It is also possible to distribute the services across several virtual machines;
 we have not thoroughly explored the performance implications of this choice.
 
\end_layout

\begin_layout Standard
Administrators frequently benefit from having separate ``development'' and
 ``production'' Freegols for a given application.
 The virtualization approach makes it easy for us to deploy these quickly
 at minimal cost.
 
\end_layout

\begin_layout Subsection
Data storage services
\end_layout

\begin_layout Standard
The storage software consists of three backend storage systems for the three
 storage layers (RAM cache, disk cache, and long term storage), a manifest
 name server, and an API used by Freegols.
 
\end_layout

\begin_layout Standard
The warehouse API contains most of the intelligence.
 It helps applications split and combine data into 64 megabyte blocks; it
 chooses RAM or disk cache for different block sizes according to tunable
 settings; it constructs hashes when storing data; it avoids writing blocks
 to cache if they are already present; and it constructs and parses manifests.
 
\end_layout

\begin_layout Standard
The API is built on the assumption that all of the underlying storage services
 are unreliable.
 It verifies data integrity during retrieval operations.
 It attempts to retrieve blocks from alternate sources when data is corrupted
 or missing.
 
\end_layout

\begin_layout Standard
The function of the storage servers is simply to read and write blocks as
 quickly as possible.
 
\end_layout

\begin_layout Standard
RAM cache is implemented with Memcached.
 Memcached has a built-in limit of 1 megabyte for each data block, and our
 API uses this as the default maximum size for cached items; however, if
 the application specifies a larger limit, the API transparently splits
 larger blocks in 1 megabyte chunks when storing, and reassembles them when
 retrieving them.
 
\end_layout

\begin_layout Standard
Disk cache is implemented with MogileFS.
 The main bottleneck in MogileFS is looking up paths from the controller;
 our API uses Memcached to cache these paths.
 
\end_layout

\begin_layout Standard
For long term storage, we implement a simple service called Keep.
 The Keep server accepts HTTP ``GET'' and ``PUT'' requests.
 The client API is responsible for replication, fault tolerance, and load
 balancing as described below.
 
\end_layout

\begin_layout Standard
A ``PUT'' request is a signed request to copy data from cache to long term
 storage.
 The Keep server fetches the data itself from the local cache or from a
 remote warehouse, according to the hints that come with the request.
 When a ``PUT'' request results in a disk write, an accounting entry is
 also recorded, with the requestor's IP address and cryptographic signature.
 Currently, the server does not verify the signature because this has not
 been necessary in our environment, but it does demand that each request
 arrive in the form of a PGP signed message.
 It also records the requestor's IP address, the time of the request, and
 the full text of the request; and it requires that the message include
 a timestamp within 5 minutes of the server's system clock.
\end_layout

\begin_layout Standard
A ``GET'' request is fulfilled by looking in one directory of each local
 disk for a file with the specified name.
\end_layout

\begin_layout Standard
The API uses MD5 checksums to distribute blocks evenly among the available
 Keep nodes.
 First, we specify that a given warehouse has a fixed number of Keep nodes.
 We then define eight preferred storage positions for each block, corresponding
 to substrings of its 128-bit MD5 checksum (see ``bits'' in Table 
\begin_inset LatexCommand ref
reference "tab:Keep"

\end_inset

).
 These portions of the checksum, modulo the number of Keep nodes, determine
 the probe order for storing that block.
 After calculating a probe position, it is removed from the list of available
 Keep nodes for the next iteration.
 
\end_layout

\begin_layout Standard
\begin_inset Float table
wide true
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="10" columns="7">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell multicolumn="1" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Standard
acbd18db4cc2f85cedef654fccc4a4d8
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
N=#nodes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
P=probe
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
bits
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
hash
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
hash%(N-p)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
available
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
target node
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
48
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0-31
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
acbd18db
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
43
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0..47
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
43
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
48
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
32-63
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
4cc2f85c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
14
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0..42,44..47
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
14
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
48
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
64-95
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
edef654f
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
31
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0.13,15..31,33..42,44..47
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
32
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
48
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
96-127
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
cc4a4d8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Standard
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0..13,15..30,33..42,44..47
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
48
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
112-127,0-15
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
a4d8acbd
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
37
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Standard
1..13,15..31,33..42,44..47
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
40
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
48
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
16-47
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
18db4cc2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
38
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
1..13,15..30,32..39,41,42,44..47
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
42
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
48
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
48-79
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
f85cedef
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
9
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
1..13,15..30,32..39,41,44..47
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
10
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
48
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
80-111
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
654fccc4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
26
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
1..9,11,13,15..30,32..39,41,44..47
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
29
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
The MD5 checksum of a block dictates a sequence of Keep nodes.
 This allows the API to read and write blocks without ever contacting a
 central controller.
\begin_inset LatexCommand label
name "tab:Keep"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
When a block has been written to Keep, the client API notes which of the
 eight preferred Keep nodes were used, and encodes this information as a
 hexadecimal representation of a bitmap, where the least significant bit
 corresponds to the first preferred storage position.
 In the above example, if the first write failed but the second and third
 writes were successful, the bitmap would be encoded as 06.
 This bitmap, the name of the warehouse, and the size of the block (3 bytes
 in this case) are appended to the MD5 checksum: 
\end_layout

\begin_layout Quote

\family typewriter
\series bold
\size scriptsize
acbd18db4cc2f85cedef654fccc4a4d8+3+K06@templeton
\end_layout

\begin_layout Standard
This resulting ``hash'', stored in a manifest, provides enough information
 for a Freegol or a batch job to retrieve the block regardless of which
 cluster it is running on.
\end_layout

\begin_layout Standard
The database of manifest names and keys is kept in a MySQL database, which
 is updated and queried through the ``warehoused'' server.
 Any Freegol can retrieve the key currently associated with a given name,
 or the entire list of names and keys.
 A Freegol can also submit a signed request to update the database by changing
 the key for a given name, or adding a new name.
 Currently, the ``warehoused'' server does not verify signatures of these
 requests because this has not been necessary in our environment, but it
 does demand that each update request arrive in the form of a PGP signed
 message, and that the Freegol correctly specify the key currently associated
 with the name.
\end_layout

\begin_layout Standard
The Freegol API includes functions for reading and writing blocks to the
 three storage systems.
 The API also provides convenient functions for constructing manifests while
 storing data, reading streams and individual files from an existing manifest,
 looking up manifest keys by name, and updating the name database.
\end_layout

\begin_layout Subsection
Batch processing services
\end_layout

\begin_layout Standard
Our batch processing system, see Figure\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Batch-processing"

\end_inset

, uses Slurm to reserve a set of nodes for each job, and to coordinate communica
tion between compute nodes and the controller, but it manages the scheduling
 of individual job steps itself.
 The ``warehoused'' server accepts signed job submissions from Freegols,
 and allows them to retrieve information about previously submitted jobs.
 The ``mapinit'' daemon starts queued job when the compute nodes become
 available.
 ``Mrjobmanager'' invokes the ``mr-function'' given in the job submission,
 which examines the input object (normally a manifest) and instructs the
 job manager to queue a number of job steps.
 The specified version of the mr-function program itself is retrieved from
 a Subversion repository.
\end_layout

\begin_layout Standard
The ``warehoused'' server accepts new job requests from Freegols and inserts
 the job specification into a MySQL database table.
 When the ``mapinit'' daemon notices that a new job has appeared in the
 database, it allocates nodes using Slurm's ``salloc'' command, and invokes
 mrjobmanager.
 Mrjobmanager allocates individual job steps to compute nodes, monitors
 their output and exit codes to detect failures, and re-queues them when
 they fail.
 Each job is expected to store output in the warehouse and send the blocks'
 names to mrjobmanager by printing it to its standard error file descriptor.
 When all job steps have completed, mrjobmanager reads these blocks and
 assembles them into a final output stream.
 This final output stream is expected to be a manifest, although this is
 not enforced.
 Finally, the database table is updated to reflect the output key (ie., a
 list of output blocks) and the time when the job finished.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Graphics
	filename /home/awz/Desktop/diagram2.eps
	width 3in

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Caption

\begin_layout Standard
Batch processing is initiated by Freegols and supervised by mrjobmanager.
 SLURM is used to allocate warehouse nodes; mrjobmanager assigns individual
 job steps to the allocated nodes and collates their output.
 The MySQL database has progress statistics for current jobs, and an archive
 of previous job submissions and results.
\begin_inset LatexCommand label
name "fig:Batch-processing"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
While a job is running, mrjobmanager keeps the job table updated with the
 number of job steps in progress, finished, and remaining.
 These figures can be retrieved by any Freegol via the warehoused server,
 and displayed to users as a progress indicator.
\end_layout

\begin_layout Standard
Batch jobs are implemented as ``mr-functions''.
 As well as performing job step computations, each mr-function is responsible
 for submitting a list of job steps to mrjobmanager.
\end_layout

\begin_layout Standard
Before a job is submitted, the code for the relevant mr-function must be
 stored in a Subversion repository on the cluster.
 The job submission includes the name of the mr-function as well as the
 desired revision number.
 Mrjobmanager takes care of installing the requested revision on each node
 before starting a job step on it.
\end_layout

\begin_layout Standard
Order of execution and output assembly is controlled by job step numbers
 and level numbers.
 Step numbers begin at zero and are assigned sequentially by mrjobmanager;
 in the final stage of mrjobmanager the step numbers determine the order
 in which the job steps' output fragments are assembled into the final output
 stream.
 Level numbers can be used by mr-functions to control the order in which
 job steps are scheduled: a job step with level L will never begin until
 all job steps with level less than L have completed.
 Each job step can also be given a short input string; this can be used
 by the mr-function to keep track of which portion of the job each step
 is expected to compute, in case the job step number itself is not convenient
 for that purpose.
\end_layout

\begin_layout Standard
Typically, an mr-function completes step 0 by reading its input manifest
 and submitting one new job step for each stream in the manifest.
 Each of these job steps will read the input stream data, write output data
 in the form of a stream, store the stream description (one line of the
 manifest) as a short block in the cache, and report the hash of this short
 block to the job manager.
 When all job steps have finished, mrjobmanager looks up all of the individual
 job step hashes and assembles them, ordered by job step number, into one
 final output manifest.
\end_layout

\begin_layout Section
Applications and results
\end_layout

\begin_layout Subsection
Freegols
\end_layout

\begin_layout Standard
We have implemented a few sample applications which demonstrate the warehouse
 API and allow us to characterize performance.
\end_layout

\begin_layout Standard
The Genomerator application is a storage/publication service.
 It currently allows users to browse and download images from a 300-gigabyte
 PMAGE dataset 
\begin_inset LatexCommand cite
key "Kim2007"

\end_inset

.
 In interactive mode, it converts images from TIFF to JPEG format and applies
 an ImageMagick ``normalize'' operation to increase contrast.
\end_layout

\begin_layout Standard
The Regol application continuously re-schedules previously completed batch
 jobs, using the same inputs and parameters but substituting the current
 revision of the relevant mr-function.
 This helps us notice bugs as they are introduced into the source code repositor
y.
 It is also a good source of information about performance characteristics
 of mr-functions, hardware configurations, and resource usage patterns.
 Regol is deployed on our ``templeton'' cluster and is able to view and
 submit jobs on both clusters.
\end_layout

\begin_layout Standard
The Deputies web interface provides a generic job submission and monitoring
 interface.
 Users can select an mr-function and revision number, choose an input manifest
 from the list provided by the warehoused server, and specify tunable parameters
 specific to the mr-function.
 Each of our clusters has its own Deputies web interface.
\end_layout

\begin_layout Subsection
Mr-functions 
\end_layout

\begin_layout Standard
The mr-functions we have implemented are generally concerned with problems
 in bioinformatics, in particular, all aspects of low cost DNA sequencing.
 We intend to elaborate on these applications in a separate article.
 Here we present some simpler applications that give a rudimentary illustration
 of the platform.
 Timing results from a few of these can be found in Table\InsetSpace ~

\begin_inset LatexCommand ref
reference "tab:templeton timing"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

mr-pivot-images'' reads a manifest with F images in each of C streams (one
 per imaging cycle) -- the way the images arrive from the acquisition system
 -- and outputs a manifest with C images in each of F streams (one per frame
 position on the slide).
 The resulting manifest is suitable for image alignment and analysis.
 This is a relatively inefficient operation because each of F job steps
 reads pieces from each of C streams.
 It performs 3275 gigabytes of I/O on our 300-gigabyte input data set.
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

mr-segment'' reads images (TIFF, raw, JPEG2000), applies a combination of
 ImageMagick filters, and optionally compresses resulting raw image using
 gzip.
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

mr-zhash'' uncompresses its input (if compressed), computes hashes for individua
l files, and outputs text files similar to the output of the Linux ``md5sum''
 command line tool.
 It is useful for determining whether two compressed data sets are equal
 when decompressed.
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

mr-copy'' writes a copy of a data set read from a remote warehouse (to make
 subsequent computation faster) or from the local warehouse (to verify that
 all data is readable and passes checksum verification).
\end_layout

\begin_layout Standard
\align center
\begin_inset Float table
wide true
sideways false
status open

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="6">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
MR-FUNCTION
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
INPUT(GB)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
DISK I/O (GB)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
NODES
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
BEST TIME(S)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
BEST CLUSTER I/O
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
mr-copy
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
300
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
600
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
15
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
901
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
665 MB/s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
mr-pivot-images
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
300
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
3275
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
47
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
3240
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
1010 MB/s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
mr-pivot-images
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
300
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
3275
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
3917
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
836 MB/s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
mr-segment
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
300
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
318
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
47
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
1145
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
277 MB/s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
mr-zhash (md5)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
300
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
300
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
32
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
711
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
421 MB/s
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Caption

\begin_layout Standard
Timing figures from the templeton cluster show a range of I/O speeds for
 various mr-functions and node allocations.
\begin_inset LatexCommand label
name "tab:templeton timing"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Storage tools
\end_layout

\begin_layout Standard
We use two command line tools to move data back and forth between the warehouse
 and a local filesystem.
  ``whput'' copies a unix filesystem tree to the cache, stores the resulting
 manifest in the cache, and optionally attaches a name to the manifest via
 the warehouse controller.
 ``whget
\begin_inset Quotes erd
\end_inset

 fetches a manifest from the warehouse, downloads the blocks, computes the
 MD5 checksums of the individual files, and optionally writes the files
 to the local filesystem.
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

whget.cgi
\begin_inset Quotes erd
\end_inset

 provides a web interface to the contents of a manifest.
 It allows users to view filenames and sizes, click individual files to
 download them, and download the manifest file itself.
 Along with Apache's mod_rewrite module, this makes it easy for an administrator
 to selectively publish individual data sets.
\end_layout

\begin_layout Subsection
Performance and reliability
\end_layout

\begin_layout Standard
\align left
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\align center
\begin_inset Graphics
	filename /home/awz/Desktop/final.eps
	lyxscale 40
	width 3in

\end_inset


\begin_inset Caption

\begin_layout Standard
Two concurrent jobs on Templeton over time
\end_layout

\end_inset


\begin_inset LatexCommand label
name "fig:Two Concurrent Jobs"

\end_inset


\end_layout

\end_inset

In Figure\InsetSpace ~

\begin_inset LatexCommand ref
reference "fig:Two Concurrent Jobs"

\end_inset

 the repeatability of two jobs, ``mr-raw'' and ``mr-jp2'', is illustrated.
 Most of the individual jobs were scheduled by ``regol'' but all jobs of
 this type, on the same input, are plotted.
 These jobs are running simultaneously; they perform approximately one terabyte
 of input and output in each pair of runs.
 The ``jp2'' job uses the lossless JPEG2000 format to compress the image
 data and is CPU intensive.
 The ``raw'' job is primarily limited by I/O.
 By inspection it's clear the cluster achieves in excess of 400 MB/sec of
 I/O: one terabyte in total, divided by 2500 seconds for the slower job.
 The solid shapes indicate successful jobs, as verified by the content hash
 of the output.
 The hollow shapes are jobs that failed for some reason.
 Each vertical line represents an update of the mr-function programs, that
 is, a commit to the subversion repository.
 If a string of failures begins at a vertical line and ends at another vertical
 line, it's most likely that the failures were caused by an update.
 
\end_layout

\begin_layout Standard
To futher explore the aggregate I/O and computational capacity of both clusters,
 we ran a selection of 
\begin_inset Quotes eld
\end_inset

mr-zhash
\begin_inset Quotes erd
\end_inset

 cryptographic hash functions concurrently with the 
\begin_inset Quotes eld
\end_inset

mr-pivot
\begin_inset Quotes erd
\end_inset

 function described above.
 The input to mr-zhash is compressed data; in each job, the amount of data
 processed is over 100 times the amount read from the warehouse cache.
 This mixture of computation-intensive and I/O-intensive work was repeated
 over a 16 hour period, using 42 compute nodes on each cluster.
 Over the 16 hour period, 
\begin_inset Quotes eld
\end_inset

mr-zhash
\begin_inset Quotes erd
\end_inset

 processed 102 TB of uncompressed data (1500 MB/s on templeton, 380 MB/s
 on uncle) while 
\begin_inset Quotes eld
\end_inset

mr-pivot-images
\begin_inset Quotes erd
\end_inset

 performed 74 TB of I/O (1000 MB/s on templeton, 290 MB/s on uncle).
\end_layout

\begin_layout Standard
In the above test, we ran 
\begin_inset Quotes eld
\end_inset

mr-zhash
\begin_inset Quotes erd
\end_inset

 in sets of twelve concurrent jobs -- for each of six hash functions, one
 job with the warehouse RAM cache enabled, and one without.
 The results are summarized in Table\InsetSpace ~

\begin_inset LatexCommand ref
reference "tab:IO_compute_table"

\end_inset

.
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="1">
<features>
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Graphics
	filename /home/awz/Desktop/uncle.eps
	lyxscale 40
	width 3in

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
\begin_inset Graphics
	filename /home/awz/Desktop/temp.eps
	lyxscale 40
	width 3in

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Caption

\begin_layout Standard
Computionally intensive jobs with RAM and disk cache versus jobs with disk
 cache only.
 
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Float table
wide true
sideways false
status collapsed

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="6">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell multicolumn="1" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Standard
Templeton
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Standard
Uncle
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
nodes
\end_layout

\end_inset
</cell>
</row>
<row bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
megabytes/sec
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
total terabytes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
megabytes/sec
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
total terabytes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
aggregate IO (mr-pivot)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
1000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
58
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
290
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
30
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
aggregate computation (mr-zhash)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
1500
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
81*
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
380
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
21*
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
12
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Caption

\begin_layout Standard
Two concurrent jobs on both Templeton and Uncle.
 *uncompressed totals are shown.
\begin_inset LatexCommand label
name "tab:IO_compute_table"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Future Directions 
\end_layout

\begin_layout Standard
We developed Free Factories to address the needs of the Personal Genome
 Project, and to help the PGx team win the Archon Genomics X-prize.
\end_layout

\begin_layout Standard
The Archon X-prize requires the sequencing of one hundred full genomes in
 less than ten days.
 Using Polony sequencing 
\begin_inset LatexCommand cite
key "Shendure2005"

\end_inset

, the PGx team will need to distill many petabytes of raw data to produce
 about one hundred gigabytes of output.
 The Free Factory platform brings us closer to this goal by minimizing the
 total cost of scalable computation and storage.
\end_layout

\begin_layout Standard
The Personal Genome Project is creating an online personal genomics community
 for one hundred thousand volunteers.
 The community will be organized around a subset of the full genome 
\begin_inset LatexCommand cite
key "Porreca2007"

\end_inset

, phenotype and medical records of volunteers.
 Leveraging the same Polony sequencing technology, the PGP will need to
 process tens of petabytes of raw data.
\end_layout

\begin_layout Standard
The Free Factory platform allows us to rapidly repurpose computational and
 storage capacity where it has the most value.
 At first, it makes sense to store multi-terabyte raw image data sets because
 storage is underutilized and it is worthwhile to tune the distillation
 process by which we obtain DNA sequences from images.
 As processed data accumulates and displaces raw data, we focus our computations
 on the processed data.
 DNA itself is an excellent archival medium and we expect new technologies
 will continue to dramatically reduce the cost of DNA sequencing, so the
 incentive to keep the raw data diminishes.
\end_layout

\begin_layout Standard
For our projects -- and we believe this is true for others too -- it is
 difficult to budget for computation and storage needs.
 How much we want depends on how much it costs.
 A platform for universal personalized medicine should permit individuals
 to form small communities that suit their own needs, while retaining much
 of the economy of scale available to much larger communities.
 We believe that this can be achieved by building a highly decentralized
 global network of Free Factories which allocate underutilized resources
 through market mechanisms.
\end_layout

\begin_layout Standard
Finally, in the spirit of free and open source software, we hope others
 will deploy Free Factories of their own for applications we have never
 imagined.
\end_layout

\begin_layout Standard
\begin_inset LatexCommand bibtex
options "plain"
bibfiles "references/awz-references"

\end_inset


\end_layout

\end_body
\end_document
