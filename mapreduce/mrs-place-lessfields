#!/usr/bin/perl
# -*- mode: perl; perl-indent-level: 2; -*-

use strict;

my @fieldname;
my @fieldtype;
my %col;			# fieldname => col#
my $mercount;
my $have_answer_key;
my $answer_key_has_smallgaps;
my %answer_key_offset;

my @mersize;
my @gapmin;
my @gapmax;
for (split (/,/, $ENV{KNOB_MERS_AND_GAPS}))
{
  if (@mersize > @gapmin)
  {
    my @gap = split (/-/);
    push @gapmin, $gap[0];
    push @gapmax, $gap[-1];
  }
  else
  {
    push @mersize, $_;
  }
}

while (<>)
{
  if (/^\#/)
  {
    if (!defined ($mercount) && /^\# field "(.*?)" "(.*?)"/)
    {
      push @fieldname, $1;
      push @fieldtype, $2;
      $col{$1} = $#fieldname;
    }
    next;
  }
  if (!defined $mercount)
  {
    $mercount = grep { /^pos\d+$/ } @fieldname;
    print <<EOF;
#: taql-0.1/text
# field "sample" "uint32"
# field "side" "int8"
# field "snps" "int8"
# field "ref" "sym"
EOF
    ;
    for (0..$mercount-1)
    {
      print qq{\# field "pos$_" "uint32"\n};
    }
    if ($have_answer_key = exists $col{"start"} && exists $col{"gap0"})
    {
      $answer_key_has_smallgaps = exists $col{"gap$mercount"};
      for (0..$mercount-1)
      {
	print qq{\# field "orig$_" "uint32"\n};
      }
      print qq{\# field "correct" "int8"\n};
      get_answer_key_offsets();
    }
    print qq{\#.\n};
  }
  my (@fields) = split (/ /);
  my @pos = map { $fields[$col{"pos$_"}] } (0..$mercount-1);
  my $snps = grep { $fields[$col{"snppos$_"}] ne "-1" } (0..$mercount-1);
  my @out = ($fields[$col{"sample"}],
	     $fields[$col{"side"}],
	     $snps,
	     $fields[$col{"ref"}],
	     @pos);
  if ($have_answer_key)
  {
    my $correct = 1;
    my @answer_pos;
    $answer_pos[0] = $fields[$col{"start"}];
    $correct &&= $answer_pos[0] == $pos[0];
    for (my $m=1, my $g=0; $m < $mercount; $m++)
    {
      $answer_pos[$m] = $answer_pos[$m-1];
      $answer_pos[$m] += $mersize[$m-1];
      $answer_pos[$m] += $gapmin[$m-1];
      for (my $smallgap=0; $smallgap <= $answer_key_has_smallgaps; $smallgap++)
      {
	$answer_pos[$m] += $fields[$col{"gap$g"}];
	$answer_pos[$m] += $ENV{KNOB_SMALLGAPMIN} if $smallgap;
	$g++;
      }
      $correct &&= $answer_pos[$m] == $pos[$m] + $answer_key_offset{$fields[$col{"ref"}]};
    }
    push @out, @answer_pos;
    push @out, ($correct ? 1 : 0);
  }
  print "@out\n";
}

sub get_answer_key_offsets
{
  my $whc = new Warehouse;
  my $manifest = new Warehouse::Manifest (whc => $whc,
					  key => $manifestkey);
  my $offset = 0;
  $manifest->rewind;
  while (my $instream = $manifest->subdir_next)
  {
    while (my ($pos, $size, $filename) = $instream->file_next)
    {
      last if !defined $pos; 
      if ($filename =~ m/hap|rand/) {
	next; 
      }
      if ($filename =~ m/\.fa$/i) 
      {
	$answer_key_offset{"\"$filename\""} = $offset;
	$offset += $size;
      }
    }
  }
}
