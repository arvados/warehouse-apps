#!/usr/bin/perl

use strict;
use DBI;
use POSIX ':sys_wait_h';
use Fcntl qw(F_GETFL F_SETFL O_NONBLOCK);

do '/etc/polony-tools/config.pl';
my $max_njobs = 32;		# max "big job" concurrency



$SIG{CHLD} = 'IGNORE';



my $dbh = DBI->connect($main::mapreduce_dsn,
		       $main::mapreduce_mysql_username,
		       $main::mapreduce_mysql_password);
die $DBI::errstr if !$dbh;
createtables ($dbh);



# Wait for jobs to appear in the queue; start them; repeat.

my %job_proc;
my $children = 0;
my $sth;
while (1)
{
  my @row;
  if (!defined ($sth) || !(@row = $sth->fetchrow))
  {
    $sth = $dbh->prepare ("select id, nodes, revision from mrjob
                           where jobmanager_id is null");
    $sth->execute or die $dbh->errstr;
  }

  if (@row)
  {
    my ($job_id, $job_nodes, $job_revision) = @row;

    next if exists $job_proc{$job_id};

    my $child = fork();
    if (!defined $child)
    {
      warn "Couldn't fork: $!";
    }
    elsif ($child)
    {
      $job_proc{$job_id} = $child;
      # XXX shouldn't have to reconnect here??? XXX
      $dbh = DBI->connect($main::mapreduce_dsn,
			  $main::mapreduce_mysql_username,
			  $main::mapreduce_mysql_password);
      die $DBI::errstr if !$dbh;
      if ($children >= $max_njobs)
      {
	my $finishedchild = wait;
	delete $job_proc{$finishedchild};
      }
      else
      {
	++$children;
      }
    }
    else
    {
      $SIG{CHLD} = 'DEFAULT';
      close(STDIN);

      $dbh->{InactiveDestroy} = 1;
      undef $dbh;
      undef $sth;

      my @nodes_arg;
      if ($job_nodes =~ /^\d+$/)
      {
	@nodes_arg = ("--nodes", $job_nodes);
      }
      else
      {
	$job_nodes =~ s/\s+/,/g;
	@nodes_arg = ("--nodelist", $job_nodes);
      }
      print join (" ", "salloc", @nodes_arg, "mrjobmanager", $job_id, "\n");
      exec ("salloc", @nodes_arg, "mrjobmanager", $job_id);
      exit (1);
    }
  }
  sleep (5);

  if (my $finishedchild = waitpid (-1, WNOHANG) > 0)
  {
    delete $job_proc{$finishedchild};
    --$children;
  }
}


sub createtables
{
  my $dbh = shift;
  foreach (qq{
create table if not exists mrlog (
 id bigint not null auto_increment primary key,
 time datetime not null,
 jobid bigint,
 jobstepid bigint,
 message varchar(255)
)
  },
	   qq{
create table if not exists mrjob (
 id bigint not null auto_increment primary key,
 revision bigint not null,
 mrfunction varchar(64),
 nprocs int,
 nodes text,
 knobs text,
 input0 text,
 starttime datetime,
 finishtime datetime,
 jobmanager_id bigint,
 success tinyint
)
  },
	   qq{
create table if not exists mrjobstep (
 id bigint not null auto_increment primary key,
 jobid bigint not null,
 level int not null,
 input varchar(255),
 submittime datetime,
 starttime datetime,
 finishtime datetime,
 node varchar(63),
 exitcode int,
 stderr text,
 attempts int not null default 0,
 index(jobid)
)
  },
	   qq{
create table if not exists mrjobmanager (
 id bigint not null auto_increment primary key,
 node varchar(63),
 starttime datetime,
 finishtime datetime,
 revision bigint,
 pid bigint
)
  })
  {
    my $sth = $dbh->prepare ($_);
    $sth->execute or die $dbh->errstr;
  }
}
