#!/usr/bin/perl

use strict;
use DBI;
use POSIX ':sys_wait_h';
use Fcntl qw(F_GETFL F_SETFL O_NONBLOCK);

do '/etc/polony-tools/config.pl';
my $max_njobs = 32;		# max "big job" concurrency



my $dbh = DBI->connect($main::mapreduce_dsn,
		       $main::mapreduce_mysql_username,
		       $main::mapreduce_mysql_password);
die $DBI::errstr if !$dbh;
createtables ($dbh);



# Wait for jobs to appear in the queue; start them; repeat.

my %job_proc;
my %proc_job;
my $children = 0;
my $sth;
while (1)
{
  my @row;
  if (!defined ($sth) || !(@row = $sth->fetchrow))
  {
    $sth = $dbh->prepare ("select id, nodes, revision from mrjob
                           where jobmanager_id is null
                           and submittime>date_add(now(),interval -1 day)");
    $sth->execute or die $dbh->errstr;
  }

  if (@row)
  {
    my ($job_id, $job_nodes, $job_revision) = @row;

    next if exists $job_proc{$job_id};

    my $child = fork();
    if (!defined $child)
    {
      warn "Couldn't fork: $!";
    }
    elsif ($child)
    {
      # XXX shouldn't have to reconnect here??? XXX
      $dbh = DBI->connect($main::mapreduce_dsn,
			  $main::mapreduce_mysql_username,
			  $main::mapreduce_mysql_password);
      die $DBI::errstr if !$dbh;

      debuglog ("pid $child started");
      $job_proc{$job_id} = $child;
      $proc_job{$child} = $job_id;

      if ($children >= $max_njobs)
      {
	my $finishedchild = wait;
	debuglog ("pid $finishedchild finished");
	delete $job_proc{$proc_job{$finishedchild}};
	delete $proc_job{$finishedchild};
      }
      else
      {
	++$children;
      }
    }
    else
    {
      close(STDIN);

      $dbh->{InactiveDestroy} = 1;
      undef $dbh;
      undef $sth;

      my @nodes_arg;
      if ($job_nodes =~ /^\d+$/)
      {
	@nodes_arg = ("--nodes", $job_nodes);
      }
      else
      {
	$job_nodes =~ s/\s+/,/g;
	@nodes_arg = ("--nodelist", $job_nodes);
      }
      debuglog ("salloc --immediate @nodes_arg mrjobmanager $job_id");
      exec ("salloc", "--immediate", @nodes_arg, "mrjobmanager", $job_id);
      exit (1);
    }
  }
  sleep (5);

  my $finishedchild = waitpid (-1, WNOHANG);
  if ($finishedchild > 0)
  {
    debuglog ("pid $finishedchild finished");
    delete $job_proc{$proc_job{$finishedchild}};
    delete $proc_job{$finishedchild};
    --$children;
  }
}


sub debuglog
{
  print STDERR (@_, "\n") if $ENV{MR_DEBUG};
}


sub createtables
{
  my $dbh = shift;
  foreach (qq{
create table if not exists mrlog (
 id bigint not null auto_increment primary key,
 time datetime not null,
 jobid bigint,
 jobstepid bigint,
 message varchar(255)
)
  },
	   qq{
create table if not exists mrjob (
 id bigint not null auto_increment primary key,
 global_id varchar(64),
 revision bigint not null,
 mrfunction varchar(64),
 nprocs int,
 nodes text,
 knobs text,
 input0 text,
 submittime datetime,
 starttime datetime,
 finishtime datetime,
 jobmanager_id bigint,
 success tinyint,
 unique(global_id)
)
  },
	   qq{
create table if not exists mrjobstep (
 id bigint not null auto_increment primary key,
 jobid bigint not null,
 level int not null,
 input varchar(255),
 submittime datetime,
 starttime datetime,
 finishtime datetime,
 node varchar(63),
 exitcode int,
 stderr text,
 attempts int not null default 0,
 index(jobid)
)
  },
	   qq{
create table if not exists mrjobmanager (
 id bigint not null auto_increment primary key,
 node varchar(63),
 starttime datetime,
 finishtime datetime,
 revision bigint,
 pid bigint
)
  })
  {
    my $sth = $dbh->prepare ($_);
    $sth->execute or die $dbh->errstr;
  }
}
