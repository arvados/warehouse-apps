#!/usr/bin/perl

###MR_DESCRIPTION:(frame ID, cycles) -> gzipped stack of raw images
###MR_INPUT:frames

use strict; 
use Compress::Zlib; 
use Image::Magick;

if ($ENV{MR_LEVEL} == 0)
{
    $ENV{MR_INPUT} = $manifestkey;
    do "mrtask-queuesubdirs"; 
}
elsif ($ENV{MR_LEVEL} == 1)
{
  my $wantsubdir = $ENV{MR_INPUT};
  my $whc = new Warehouse
      (memcached_size_threshold => $ENV{KNOB_MEMCACHED_SIZE});

  my $manifest = new Warehouse::Manifest (whc => $whc,
					  key => $manifestkey);
  $manifest->rewind;
  while (my $instream = $manifest->subdir_next)
  {
    if ($instream->name eq $wantsubdir)
    {
      my $outstream = new Warehouse::Stream (whc => $whc);
      $outstream->name ($instream->name);
      $outstream->clear;

      while (my ($pos, $size, $filename) = $instream->file_next)
      {
	last if !defined $pos;
	if ($filename =~ s/\.g?z$//i) # should uncompress (not simply rename!) 
	{
	  $outstream->write_start ($filename);
	  $instream->seek ($pos);
	  while (my $dataref = $instream->read_until ($pos + $size))
	  {
	    $outstream->write_data ($dataref);
	  }
	  $outstream->write_finish;
	}
	else
	{
	  $outstream->write_start ($filename);
	  $instream->seek ($pos);
	  while (my $dataref = $instream->read_until ($pos + $size))
	  {
	    $outstream->write_data ($dataref);
	  }
	  $outstream->write_finish
	}
    }
  }
  die "Subdir not found: $wantsubdir";
}
