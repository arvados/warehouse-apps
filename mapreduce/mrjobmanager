#!/usr/bin/perl
# -*- mode: perl; perl-indent-level: 2; -*-

# mrjobmanager: initiate and supervise all map and reduce tasks for one job.
#
# 1. Find lowest reduce task level for this job
# 2. Run all reduce tasks with this lowest level
#    (this may cause more tasks to be queued)
# 3. Repeat from #1 until no tasks remain.

use strict;
use DBI;
use POSIX ':sys_wait_h';
use Fcntl qw(F_GETFL F_SETFL O_NONBLOCK);
use Warehouse;
use Warehouse::Stream;

do '/etc/polony-tools/config.pl';



$SIG{'USR1'} = sub
{
  $main::ENV{MR_DEBUG} = 1;
};
$SIG{'USR2'} = sub
{
  $main::ENV{MR_DEBUG} = 0;
};



my ($job_id) = @ARGV;



my $dbh = DBI->connect($main::mapreduce_dsn,
		       $main::mrcontrol_mysql_username,
		       $main::mrcontrol_mysql_password);
die $DBI::errstr if !$dbh;



my $whc = new Warehouse or die "failed to create Warehouse client";
my $metastream = new Warehouse::Stream (whc => $whc);
$metastream->clear;
$metastream->name (".");
$metastream->write_start ("log.txt");



my $sth = $dbh->prepare ("select * from mrjob where id=?");
$sth->execute ($job_id) or die $dbh->errstr;
my $Job = $sth->fetchrow_hashref or die $sth->errstr;
Log (undef,
     "rev $$Job{revision} function $$Job{mrfunction} knobs $$Job{knobs}");



my $max_ncpus;
map { $max_ncpus = $' if /^STEPSPERNODE=/ } split ("\n", $$Job{knobs});



Log (undef, "check slurm allocation");
my @slot;
# Should use $ENV{SLURM_TASKS_PER_NODE} instead of sinfo? (eg. "4(x3),2,4(x2)")
foreach (`sinfo -h --format='%c %N' --nodes='$ENV{SLURM_NODELIST}'`)
{
  my ($ncpus, $slurm_nodelist) = split;
  $ncpus = $max_ncpus if defined ($max_ncpus) && $ncpus > $max_ncpus && $max_ncpus > 0;

  my @nodelist;
  while ($slurm_nodelist =~ s/^([^\[,]+?(\[.*?\])?)(,|$)//)
  {
    my $nodelist = $1;
    if ($nodelist =~ /\[((\d+)(-(\d+))?(,(\d+)(-(\d+))?)*)\]/)
    {
      my $ranges = $1;
      foreach (split (",", $ranges))
      {
	my ($a, $b);
	if (/(\d+)-(\d+)/)
	{
	  $a = $1;
	  $b = $2;
	}
	else
	{
	  $a = $_;
	  $b = $_;
	}
	push @nodelist, map {
	  my $n = $nodelist;
	  $n =~ s/\[[-,\d]+\]/$_/;
	  $n;
	} ($a..$b);
      }
    }
    else
    {
      push @nodelist, $nodelist;
    }
  }
  foreach my $node (@nodelist)
  {
    Log (undef, "node $node - $ncpus slots");
    foreach my $cpu (1..$ncpus)
    {
      push @slot, { node => $node,
		    cpu => $cpu };
    }
  }
}



# Claim this job, and make sure nobody else does

$sth = $dbh->prepare ("insert into mrjobmanager
                       (pid, revision, starttime)
                       values (?, ?, now())");
my $rev = q/$Revision: 184 $/;
$rev =~ /\d+/;
$sth->execute ($$, $&) or die $dbh->errstr;

$sth = $dbh->prepare ("select last_insert_id()");
$sth->execute or die $dbh->errstr;
my ($jobmanager_id) = $sth->fetchrow_array;

$sth = $dbh->prepare ("update mrjob set jobmanager_id=?, starttime=now()
                       where id=? and jobmanager_id is null");
$sth->execute ($jobmanager_id, $job_id) or croak ($dbh->errstr);

$sth = $dbh->prepare ("select jobmanager_id from mrjob
                       where id=?");
$sth->execute ($job_id) or croak ($dbh->errstr);
my ($check_jobmanager_id) = $sth->fetchrow_array;
if ($check_jobmanager_id != $jobmanager_id)
{
  # race condition - another job manager proc stole the job
  Log (undef,
       "job taken by jobmanager id $check_jobmanager_id");
  exit (1);
}



Log (undef, "start");
$SIG{'INT'} = \&croak;
$SIG{'QUIT'} = \&croak;
$SIG{'TERM'} = \&croak;
my $time_slowest_success = 60;	# always reasonable to allow this long
my $tasks_must_output_keys = 0;	# becomes 1 when any task outputs a key



my @jobstep;
push @jobstep, { input => $Job->{input0},
		 level => 0,
		 attempts => 0,
	       };
my @jobstep_todo = (0);
my @jobstep_done = ();
my @jobstep_tomerge = ();



ONELEVEL:

my $tasks_succeeded = 0;
my $tasks_failed = 0;

@jobstep_todo = sort { $jobstep[$a]->{level} <=> $jobstep[$b]->{level}
		       or $a <=> $b } @jobstep_todo;
my $level = $jobstep[$jobstep_todo[0]]->{level};
Log (undef, "start level $level");



my %proc;
my @freeslot = (0..$#slot);
my %reader;
my ($id, $input, $attempts);
my $progress_is_dirty = 1;

update_progress_stats();



THISROUND:
for (my $todo_ptr = 0; $todo_ptr <= $#jobstep_todo; $todo_ptr ++)
{
  my $id = $jobstep_todo[$todo_ptr];
  my $Jobstep = $jobstep[$id];
  if ($Jobstep->{level} != $level)
  {
    next;
  }
  if ($Jobstep->{attempts} > 4)
  {
    croak ("jobstep $id failed $$Jobstep{attempts} times -- giving up");
  }

  pipe $reader{$id}, "writer" or croak ($!);
  my $flags = fcntl ($reader{$id}, F_GETFL, 0) or croak ($!);
  fcntl ($reader{$id}, F_SETFL, $flags | O_NONBLOCK) or croak ($!);

  my $childslot = $freeslot[0];
  my $childnode = $slot[$childslot]->{node};
  my $childslotname = join (".",
			    $slot[$childslot]->{node},
			    $slot[$childslot]->{cpu});
  my $childpid = fork();
  if ($childpid == 0)
  {
    $SIG{'INT'} = 'DEFAULT';
    $SIG{'QUIT'} = 'DEFAULT';
    $SIG{'TERM'} = 'DEFAULT';

    foreach (values (%reader))
    {
      close($_);
    }
    fcntl ("writer", F_SETFL, 0) or croak ($!); # no close-on-exec
    open(STDOUT,">&writer");
    open(STDERR,">&writer");

    $dbh->{InactiveDestroy} = 1;
    undef $dbh;
    undef $sth;


    $ENV{"MR_ID"} = $id;
    $ENV{"MR_JOB_ID"} = $job_id;
    $ENV{"MR_INPUT"} = $Jobstep->{input};
    $ENV{"MR_KNOBS"} = $Job->{knobs};
    $ENV{"MR_REVISION"} = $Job->{revision};
    $ENV{"MR_LEVEL"} = $level;
    $ENV{"MR_FUNCTION"} = $Job->{mrfunction};
    $ENV{"MR_INPUT0"} = $Job->{input0};
    $ENV{"MR_OUTPUTKEY"} = "mrjobstep/$job_id/$level/$id";
    $ENV{"MR_SLOT"} = $childslotname;
    $ENV{"INSTALL_REPOS"} = $main::svn_repos;
    $ENV{"INSTALL_REVISION"} = $Job->{revision};
    $ENV{"MOGILEFS_TRACKERS"} = join (",", @main::mogilefs_trackers);
    $ENV{"MOGILEFS_DOMAIN"} = $main::mogilefs_default_domain;
    $ENV{"MOGILEFS_CLASS"} = $main::mogilefs_default_class;

    my $execstr = "srun --nodelist='$childnode' -n1 -c1 -N1 -D /tmp --job-name='mr$job_id.$id' sh -c '/usr/local/polony-tools/installrevision && /usr/local/polony-tools/$$Job{revision}/src/mapreduce/mrtaskmanager'";
    print STDERR ("$execstr\n") if $ENV{MR_DEBUG};
    exec($execstr);
    exit(1);
  }
  close("writer");
  if (!defined $childpid)
  {
    close $reader{$id};
    delete $reader{$id};
    next;
  }
  shift @freeslot;
  $proc{$childpid} = { jobstep => $id,
		       time => time,
		       slot => $childslot,
		     };
  die "assert failed" if exists $slot[$childslot]->{pid};
  $slot[$childslot]->{pid} = $childpid;

  Log ($id, "child $childpid started on $childslotname");
  $Jobstep->{attempts} ++;
  $Jobstep->{starttime} = time;
  $Jobstep->{node} = $childnode;
  delete $Jobstep->{stderr};
  delete $Jobstep->{output};
  delete $Jobstep->{finishtime};

  splice @jobstep_todo, $todo_ptr, 1;
  --$todo_ptr;

  $progress_is_dirty = 1;

  while (!@freeslot
	 ||
	 (@slot > @freeslot && $todo_ptr+1 > $#jobstep_todo))
  {
    my $gotsome
	= readfrompipes ()
	+ reapchildren ();
    if (!$gotsome)
    {
      update_progress_stats();
      try_getting_impatient();
      select (undef, undef, undef, 0.1);
    }
    if (($tasks_failed >= 8 && $tasks_succeeded == 0) ||
	($tasks_failed >= 16 && $tasks_failed > $tasks_succeeded))
    {
      my $message = "Failure rate too high ($tasks_failed/"
	  .($tasks_failed+$tasks_succeeded)
	  .") -- giving up on this round";
      Log (undef, $message);
      last THISROUND;
    }
  }
}

Log (undef, "wait for last ".(scalar keys %proc)." children to finish");
while (%proc)
{
  readfrompipes ();
  if (!reapchildren())
  {
    update_progress_stats();
    try_getting_impatient();
    select (undef, undef, undef, 0.1);
  }
}

update_progress_stats();



if (@jobstep_tomerge && !@jobstep_todo)
{
  push @jobstep, { input => join ("\n", splice @jobstep_tomerge, 0),
		   level => $level,
		   attempts => 0 };
  push @jobstep_todo, $#jobstep;
}



# this should ensure that we terminate even if some jobs really
# do take many times longer

$time_slowest_success = $time_slowest_success * 2;

if ($tasks_succeeded > 0 || ($tasks_failed > 0 && $tasks_failed < 5))
{
  goto ONELEVEL if @jobstep_todo;
}
elsif ($tasks_failed > 0)
{
  my $message = "stop because $tasks_failed tasks failed and none succeeded";
  Log (undef, $message);
  croak ($message);
}



my $success = 1;



Log (undef, "reduce");

$whc->write_start (1);
for (@jobstep)
{
  my $output = $_->{output} or next;
  if (defined (my $outblock = $whc->fetch_block ($output)))
  {
    $whc->write_data ($outblock);
  }
  else
  {
    my $errstr = $whc->errstr;
    $whc->write_data ("XXX fetch_block($output) failed: $errstr XXX\n");
    $success = 0;
  }
}
my $key = $whc->write_finish;
if ($key)
{
  Log (undef, "output key is $key");
}
else
{
    Log (undef, "no output key");
}



# XXX shouldn't have to reconnect here??? XXX
$dbh = DBI->connect($main::mapreduce_dsn,
		    $main::mrcontrol_mysql_username,
		    $main::mrcontrol_mysql_password);
croak ($DBI::errstr) if !$dbh;



if ($key)
{
    $dbh->do ("update mrjob set output=? where id=?", undef,
	      $key, $job_id)
	or croak ($dbh->errstr);

    $whc->store_manifest_by_name ($key, undef, "/job$job_id")
	or croak ($whc->errstr);
}


Log (undef, "finish");

$sth = $dbh->prepare ("update mrjob set finishtime=now(), success=?
                       where id=? and jobmanager_id=?");
$sth->execute ($success, $job_id, $jobmanager_id)
    or croak ($dbh->errstr);

cleanup_meta();
exit 0;



sub update_progress_stats
{
  return if !$progress_is_dirty;
  my ($todo, $done, $running) = (scalar @jobstep_todo,
				 scalar @jobstep_done,
				 scalar @slot - scalar @freeslot);
  $dbh->do
      ("update mrjob set steps_todo=?,steps_done=?,steps_running=? where id=?",
       undef,
       $todo, $done, $running, $job_id);
  Log (undef, "status: $done done, $running running, $todo todo");
  $progress_is_dirty = 0;
}



sub reapchildren
{
  my $pid = waitpid (-1, WNOHANG);
  return 0 if $pid <= 0;

  my $whatslot = ($slot[$proc{$pid}->{slot}]->{node}
		  . "."
		  . $slot[$proc{$pid}->{slot}]->{cpu});
  my $jobstepid = $proc{$pid}->{jobstep};
  my $elapsed = time - $proc{$pid}->{time};
  my $Jobstep = $jobstep[$jobstepid];

  my $exitcode = $?;
  my $exitinfo = "exit $exitcode";
  if (!exists $Jobstep->{output})
  {
    $exitinfo .= " with no output key";
    $exitcode = -1 if $exitcode == 0 && $tasks_must_output_keys;
  }
  Log ($jobstepid, "child $pid on $whatslot $exitinfo");

  if ($exitcode != 0)
  {
    ++$tasks_failed;
    push @jobstep_todo, $jobstepid;
    Log ($jobstepid, "failure in $elapsed seconds");
  }
  else
  {
    ++$tasks_succeeded;
    $time_slowest_success = $elapsed
	if $time_slowest_success < $elapsed;
    push @jobstep_done, $jobstepid;
    Log ($jobstepid, "success in $elapsed seconds");
  }
  $Jobstep->{exitcode} = $exitcode;
  $Jobstep->{finishtime} = time;
  process_stderr ($jobstepid, $exitcode == 0);
  Log ($jobstepid, "output $$Jobstep{output}");

  close $reader{$jobstepid};
  delete $reader{$jobstepid};
  delete $slot[$proc{$pid}->{slot}]->{pid};
  push @freeslot, $proc{$pid}->{slot};
  delete $proc{$pid};

  $progress_is_dirty = 1;
  1;
}


sub readfrompipes
{
  my $gotsome = 0;
  foreach my $job (keys %reader)
  {
    my $buf;
    while (0 < sysread ($reader{$job}, $buf, 8192))
    {
      print STDERR $buf if $ENV{MR_DEBUG};
      $jobstep[$job]->{stderr} .= $buf;
      $gotsome = 1;
    }
  }
  return $gotsome;
}


sub process_stderr
{
  my $job = shift;
  my $success = shift;
  while ($jobstep[$job]->{stderr} =~
	 s/\+\+\+mrjobstep(?:\/(\d+|\*))? (\d+) (.*?)\+\+\+\n//)
  {
    next if !$success;
    my ($merge, $level, $input) = ($1, $2, $3);
    my $newjobref;
    if ($merge)
    {
      push @jobstep_tomerge, $input;
      if ($merge !~ /\D/ && @jobstep_tomerge >= $merge)
      {
	$newjobref = { input => join ("\n",
				      splice @jobstep_tomerge, 0, $merge),
		       level => $level,
		       attempts => 0 };
      }
    }
    else
    {
      $newjobref = { input => $input,
		     level => $level,
		     attempts => 0 };
    }
    if ($newjobref)
    {
      push @jobstep, $newjobref;
      push @jobstep_todo, $#jobstep;
    }
  }
  while ($jobstep[$job]->{stderr} =~ s/\+\+\+mrout (.*?)\+\+\+\n//)
  {
    if ($success)
    {
      $jobstep[$job]->{output} = $1;
      $tasks_must_output_keys = 1;
    }
  }
  map {
    Log ($jobstepid, "stderr $_");
  } split ("\n", $jobstep[$job]->{stderr});
}

sub try_getting_impatient
{
  if ($tasks_succeeded > keys %proc)
  {
    # enough jobsteps have succeeded that $time_slowest_success might
    # be meaningful
    if (@slot >= 2 * keys %proc)
    {
      # at least half of our task slots (cpus) are idle
      for (grep { $proc{$_}->{time} + $time_slowest_success * 2 < time }
	   keys %proc)
      {
	# pid $_ has taken more than twice as long as the longest
	# successful job in this round.  It's probably hung.  Kill
	# it, and restart it in the next round.

	my $sig = 2;		# SIGINT first
	if (exists $proc{$_}->{"sent_$sig"} &&
	    time - $proc{$_}->{"sent_$sig"} > 4)
	{
	  $sig = 15;		# SIGTERM if SIGINT doesn't work
	}
	if (exists $proc{$_}->{"sent_$sig"} &&
	    time - $proc{$_}->{"sent_$sig"} > 4)
	{
	  $sig = 9;		# SIGKILL if SIGTERM doesn't work
	}
	if (!exists $proc{$_}->{"sent_$sig"})
	{
	  Log ($proc{$_}->{jobstep}, "sending 2x signal $sig to pid $_");
	  kill $sig, $_;
	  select (undef, undef, undef, 0.1);
	  if ($sig == 2)
	  {
	    kill $sig, $_;	# srun wants two SIGINT to really interrupt
	  }
	  $proc{$_}->{"sent_$sig"} = time;
	}
      }
    }
  }
}


sub fhbits
{
  my($bits);
  for (@_) {
    vec($bits,fileno($_),1) = 1;
  }
  $bits;
}


sub Log				# ($jobstep_id, $logmessage)
{
  my $fh = select STDERR; $|=1; select $fh;
  my $message = sprintf ("%d %d %s %s\n", $job_id, $$, @_);
  print STDERR $message;

  return if !$metastream;
  my $datetime = sprintf ("%04d-%02d-%02d_%02d:%02d:%02d",
			  (gmtime)[5]+1900, (gmtime)[4,3,2,1,0]);
  $metastream->write_data ($datetime . " " . $message);
}


sub croak
{
  my ($package, $file, $line) = caller;
  my $message = "@_ at $file line $line\n";
  Log (undef, $message);
  cleanup() if $dbh;
  cleanup_meta() if $metastream;
  die;
}


sub cleanup
{
  my $sth;
  $sth = $dbh->prepare ("update mrjobmanager set finishtime=now() where id=?");
  $sth->execute ($jobmanager_id);
  $sth = $dbh->prepare ("update mrjob set success=0, finishtime=now() where id=? and jobmanager_id=? and finishtime is null");
  $sth->execute ($job_id, $jobmanager_id);
}


sub cleanup_meta
{
  $metastream->write_finish;
  my $metakey = $metastream->as_key;
  undef $metastream;
  Log (undef, "meta key is $metakey");
  $dbh->do ("update mrjob set metakey=? where id=?",
	    undef,
	    $metakey, $job_id);
}
