#!/usr/bin/perl
# -*- mode: perl; perl-indent-level: 2; -*-

# mrjobmanager: initiate and supervise all map and reduce tasks for one job.
#
# 1. Find lowest reduce task level for this job
# 2. Run all reduce tasks with this lowest level
#    (this may cause more tasks to be queued)
# 3. Repeat from #1 until no tasks remain.

use strict;
use DBI;
use POSIX ':sys_wait_h';
use Fcntl qw(F_GETFL F_SETFL O_NONBLOCK);
use Warehouse;
use Warehouse::Stream;

do '/etc/polony-tools/config.pl';



$SIG{'USR1'} = sub
{
  $main::ENV{MR_DEBUG} = 1;
};
$SIG{'USR2'} = sub
{
  $main::ENV{MR_DEBUG} = 0;
};



my ($job_id) = @ARGV;



my $dbh = DBI->connect($main::mapreduce_dsn,
		       $main::mrcontrol_mysql_username,
		       $main::mrcontrol_mysql_password);
die $DBI::errstr if !$dbh;



my $whc = new Warehouse or die "failed to create Warehouse client";
my $metastream = new Warehouse::Stream (whc => $whc);
$metastream->clear;
$metastream->name (".");
$metastream->write_start ("log.txt");



my $sth = $dbh->prepare ("select * from mrjob where id=?");
$sth->execute ($job_id) or die $dbh->errstr;
my $Job = $sth->fetchrow_hashref or die $sth->errstr;
$Job->{inputkey} = $Job->{input0} if !exists $Job->{inputkey};
delete $Job->{input0};



my $max_ncpus;
map { $max_ncpus = $1 if /^STEPSPERNODE=(.*)/ } split ("\n", $$Job{knobs});
$max_ncpus = $1 if $$Job{nodes} =~ /\&(\d+)/;
$max_ncpus = $$Job{stepspernode} if $$Job{stepspernode};



Log (undef, "check slurm allocation");
my @slot;
# Should use $ENV{SLURM_TASKS_PER_NODE} instead of sinfo? (eg. "4(x3),2,4(x2)")
foreach (`sinfo -h --format='%c %N' --nodes='$ENV{SLURM_NODELIST}'`)
{
  my ($ncpus, $slurm_nodelist) = split;
  $ncpus = $max_ncpus if defined ($max_ncpus) && $ncpus > $max_ncpus && $max_ncpus > 0;

  my @nodelist;
  while ($slurm_nodelist =~ s/^([^\[,]+?(\[.*?\])?)(,|$)//)
  {
    my $nodelist = $1;
    if ($nodelist =~ /\[((\d+)(-(\d+))?(,(\d+)(-(\d+))?)*)\]/)
    {
      my $ranges = $1;
      foreach (split (",", $ranges))
      {
	my ($a, $b);
	if (/(\d+)-(\d+)/)
	{
	  $a = $1;
	  $b = $2;
	}
	else
	{
	  $a = $_;
	  $b = $_;
	}
	push @nodelist, map {
	  my $n = $nodelist;
	  $n =~ s/\[[-,\d]+\]/$_/;
	  $n;
	} ($a..$b);
      }
    }
    else
    {
      push @nodelist, $nodelist;
    }
  }
  foreach my $node (@nodelist)
  {
    Log (undef, "node $node - $ncpus slots");
    foreach my $cpu (1..$ncpus)
    {
      push @slot, { node => $node,
		    cpu => $cpu };
    }
  }
}



# Ensure that we get one jobstep running on each allocated node before
# we start overloading nodes with concurrent steps

@slot = sort { $a->{cpu} <=> $b->{cpu} } @slot;



# Claim this job, and make sure nobody else does

$sth = $dbh->prepare ("insert into mrjobmanager
                       (pid, revision, starttime)
                       values (?, ?, now())");
my $rev = q/$Revision: 184 $/;
$rev =~ /\d+/;
$sth->execute ($$, $&) or die $dbh->errstr;

$sth = $dbh->prepare ("select last_insert_id()");
$sth->execute or die $dbh->errstr;
my ($jobmanager_id) = $sth->fetchrow_array;

$sth = $dbh->prepare ("update mrjob set jobmanager_id=?, starttime=now()
                       where id=? and jobmanager_id is null");
$sth->execute ($jobmanager_id, $job_id) or croak ($dbh->errstr);

$sth = $dbh->prepare ("select jobmanager_id from mrjob
                       where id=?");
$sth->execute ($job_id) or croak ($dbh->errstr);
my ($check_jobmanager_id) = $sth->fetchrow_array;
if ($check_jobmanager_id != $jobmanager_id)
{
  # race condition - another job manager proc stole the job
  Log (undef,
       "job taken by jobmanager id $check_jobmanager_id");
  exit (1);
}



Log (undef, "start");
$SIG{'INT'} = \&croak;
$SIG{'QUIT'} = \&croak;
$SIG{'TERM'} = \&croak;
$SIG{'TSTP'} = sub { $main::please_freeze = 1; };
$SIG{'ALRM'} = sub { $main::please_info = 1; };
$main::please_freeze = 0;
$main::please_info = 0;
my $time_slowest_success = 60;	# always reasonable to allow this long
my $jobsteps_must_output_keys = 0;	# becomes 1 when any task outputs a key



my @jobstep;
my @jobstep_todo = ();
my @jobstep_done = ();
my @jobstep_tomerge = ();
my $jobstep_tomerge_level = 0;



if (defined $Job->{thawedfromkey})
{
  thaw ($Job->{thawedfromkey});
}
else
{
  push @jobstep, { input => $Job->{inputkey},
		   level => 0,
		   attempts => 0,
		 };
  push @jobstep_todo, 0;
}



foreach (qw (mrfunction revision nodes stepspernode inputkey))
{
  Log (undef, $_ . " " . $Job->{$_});
}
foreach (split (/\n/, $Job->{knobs}))
{
  Log (undef, "knob " . $_);
}



ONELEVEL:

my $thisround_succeeded = 0;
my $thisround_failed = 0;

@jobstep_todo = sort { $jobstep[$a]->{level} <=> $jobstep[$b]->{level}
		       or $a <=> $b } @jobstep_todo;
my $level = $jobstep[$jobstep_todo[0]]->{level};
Log (undef, "start level $level");



my %proc;
my @freeslot = (0..$#slot);
my %reader;
my ($id, $input, $attempts);
my $progress_is_dirty = 1;

update_progress_stats();



THISROUND:
for (my $todo_ptr = 0; $todo_ptr <= $#jobstep_todo; $todo_ptr ++)
{
  my $id = $jobstep_todo[$todo_ptr];
  my $Jobstep = $jobstep[$id];
  if ($Jobstep->{level} != $level)
  {
    next;
  }
  if ($Jobstep->{attempts} > 4)
  {
    croak ("jobstep $id failed $$Jobstep{attempts} times -- giving up");
  }

  pipe $reader{$id}, "writer" or croak ($!);
  my $flags = fcntl ($reader{$id}, F_GETFL, 0) or croak ($!);
  fcntl ($reader{$id}, F_SETFL, $flags | O_NONBLOCK) or croak ($!);

  my $childslot = $freeslot[0];
  my $childnode = $slot[$childslot]->{node};
  my $childslotname = join (".",
			    $slot[$childslot]->{node},
			    $slot[$childslot]->{cpu});
  my $childpid = fork();
  if ($childpid == 0)
  {
    $SIG{'INT'} = 'DEFAULT';
    $SIG{'QUIT'} = 'DEFAULT';
    $SIG{'TERM'} = 'DEFAULT';

    foreach (values (%reader))
    {
      close($_);
    }
    fcntl ("writer", F_SETFL, 0) or croak ($!); # no close-on-exec
    open(STDOUT,">&writer");
    open(STDERR,">&writer");

    $dbh->{InactiveDestroy} = 1;
    undef $dbh;
    undef $sth;


    $ENV{"MR_ID"} = $id;
    $ENV{"MR_JOB_ID"} = $job_id;
    $ENV{"MR_INPUT"} = $Jobstep->{input};
    $ENV{"MR_KNOBS"} = $Job->{knobs};
    $ENV{"MR_REVISION"} = $Job->{revision};
    $ENV{"MR_REVISION_INSTALLDIR"} = "/tmp/mrcompute/revision/$Job->{revision}";
    $ENV{"MR_LEVEL"} = $level;
    $ENV{"MR_FUNCTION"} = $Job->{mrfunction};
    $ENV{"MR_INPUT0"} = $Job->{inputkey};
    $ENV{"MR_INPUTKEY"} = $Job->{inputkey};
    $ENV{"MR_OUTPUTKEY"} = "mrjobstep/$job_id/$level/$id";
    $ENV{"MR_SLOT"} = $childslotname;
    $ENV{"INSTALL_REPOS"} = $main::svn_repos;
    $ENV{"INSTALL_REVISION"} = $Job->{revision};
    $ENV{"MOGILEFS_TRACKERS"} = join (",", @main::mogilefs_trackers);
    $ENV{"MOGILEFS_DOMAIN"} = $main::mogilefs_default_domain;
    $ENV{"MOGILEFS_CLASS"} = $main::mogilefs_default_class;

    my $execstr = "srun --nodelist='$childnode' -n1 -c1 -N1 -D /tmp --job-name='$job_id.$id' sh -c 'mkdir -p /tmp/mrcompute/revision && cd /tmp/mrcompute && svn export --quiet '$main::svn_repos/installrevision' && ./installrevision && $ENV{MR_REVISION_INSTALLDIR}/src/mapreduce/mrtaskmanager'";
    print STDERR ("$execstr\n") if $ENV{MR_DEBUG};
    exec($execstr);
    exit(1);
  }
  close("writer");
  if (!defined $childpid)
  {
    close $reader{$id};
    delete $reader{$id};
    next;
  }
  shift @freeslot;
  $proc{$childpid} = { jobstep => $id,
		       time => time,
		       slot => $childslot,
		     };
  die "assert failed" if exists $slot[$childslot]->{pid};
  $slot[$childslot]->{pid} = $childpid;

  Log ($id, "child $childpid started on $childslotname");
  $Jobstep->{attempts} ++;
  $Jobstep->{starttime} = time;
  $Jobstep->{node} = $childnode;
  delete $Jobstep->{stderr};
  delete $Jobstep->{output};
  delete $Jobstep->{finishtime};

  splice @jobstep_todo, $todo_ptr, 1;
  --$todo_ptr;

  $progress_is_dirty = 1;

  while (!@freeslot
	 ||
	 (@slot > @freeslot && $todo_ptr+1 > $#jobstep_todo))
  {
    last THISROUND if $main::please_freeze;
    $main::please_info = 0, freeze(), save_meta(1) if $main::please_info;
    my $gotsome
	= readfrompipes ()
	+ reapchildren ();
    if (!$gotsome)
    {
      update_progress_stats();
      select (undef, undef, undef, 0.1);
    }
    if (($thisround_failed >= 8 && $thisround_succeeded == 0) ||
	($thisround_failed >= 16 && $thisround_failed > $thisround_succeeded))
    {
      my $message = "Failure rate too high ($thisround_failed/"
	  .($thisround_failed+$thisround_succeeded)
	  .") -- giving up on this round";
      Log (undef, $message);
      last THISROUND;
    }
  }
}


Log (undef, "wait for last ".(scalar keys %proc)." children to finish");
while (%proc)
{
  $main::please_info = 0, freeze(), save_meta(1) if $main::please_info;
  readfrompipes ();
  if (!reapchildren())
  {
    update_progress_stats();
    select (undef, undef, undef, 0.1);
    killem (keys %proc) if $main::please_freeze;
  }
}

update_progress_stats();



if ($main::please_freeze)
{
  freeze();
  cleanup();
  save_meta();
  exit 0;
}



if (@jobstep_tomerge && !@jobstep_todo)
{
  push @jobstep, { input => join ("\n", splice @jobstep_tomerge, 0),
		   level => $jobstep_tomerge_level,
		   attempts => 0 };
  push @jobstep_todo, $#jobstep;
}



# this should ensure that we terminate even if some jobs really
# do take many times longer

$time_slowest_success = $time_slowest_success * 2;

if ($thisround_succeeded > 0 || ($thisround_failed > 0 && $thisround_failed < 5))
{
  goto ONELEVEL if @jobstep_todo;
}
elsif ($thisround_failed > 0)
{
  my $message = "stop because $thisround_failed tasks failed and none succeeded";
  Log (undef, $message);
  croak ($message);
}



my $success = 1;



Log (undef, "reduce");

$whc->write_start (1);
for (@jobstep)
{
  my $output = $_->{output} or next;
  if (defined (my $outblock = $whc->fetch_block ($output)))
  {
    $whc->write_data ($outblock);
  }
  else
  {
    my $errstr = $whc->errstr;
    $whc->write_data ("XXX fetch_block($output) failed: $errstr XXX\n");
    $success = 0;
  }
}
my $key = $whc->write_finish;
if ($key)
{
  Log (undef, "output key is $key");
}
else
{
    Log (undef, "no output key");
}



# XXX shouldn't have to reconnect here??? XXX
$dbh = DBI->connect($main::mapreduce_dsn,
		    $main::mrcontrol_mysql_username,
		    $main::mrcontrol_mysql_password);
croak ($DBI::errstr) if !$dbh;



if ($key)
{
    $dbh->do ("update mrjob set output=? where id=?", undef,
	      $key, $job_id)
	or croak ($dbh->errstr);

    $whc->store_manifest_by_name ($key, undef, "/job$job_id")
	or croak ($whc->errstr);
}


Log (undef, "finish");

$sth = $dbh->prepare ("update mrjob set finishtime=now(), success=?
                       where id=? and jobmanager_id=?");
$sth->execute ($success, $job_id, $jobmanager_id)
    or croak ($dbh->errstr);

save_meta();
exit 0;



sub update_progress_stats
{
  return if !$progress_is_dirty;
  my ($todo, $done, $running) = (scalar @jobstep_todo,
				 scalar @jobstep_done,
				 scalar @slot - scalar @freeslot);
  $dbh->do
      ("update mrjob set steps_todo=?,steps_done=?,steps_running=? where id=?",
       undef,
       $todo, $done, $running, $job_id);
  Log (undef, "status: $done done, $running running, $todo todo");
  $progress_is_dirty = 0;
}



sub reapchildren
{
  my $pid = waitpid (-1, WNOHANG);
  return 0 if $pid <= 0;

  my $whatslot = ($slot[$proc{$pid}->{slot}]->{node}
		  . "."
		  . $slot[$proc{$pid}->{slot}]->{cpu});
  my $jobstepid = $proc{$pid}->{jobstep};
  my $elapsed = time - $proc{$pid}->{time};
  my $Jobstep = $jobstep[$jobstepid];

  process_stderr_for_output_key ($jobstepid);

  my $exitcode = $?;
  my $exitinfo = "exit $exitcode";
  if (!exists $Jobstep->{output})
  {
    $exitinfo .= " with no output key";
    $exitcode = -1 if $exitcode == 0 && $jobsteps_must_output_keys;
  }
  Log ($jobstepid, "child $pid on $whatslot $exitinfo");

  if ($exitcode != 0)
  {
    ++$thisround_failed;
    push @jobstep_todo, $jobstepid;
    Log ($jobstepid, "failure in $elapsed seconds");
  }
  else
  {
    ++$thisround_succeeded;
    $time_slowest_success = $elapsed
	if $time_slowest_success < $elapsed;
    push @jobstep_done, $jobstepid;
    Log ($jobstepid, "success in $elapsed seconds");
  }
  $Jobstep->{exitcode} = $exitcode;
  $Jobstep->{finishtime} = time;
  process_stderr ($jobstepid, $exitcode == 0);
  Log ($jobstepid, "output $$Jobstep{output}");

  close $reader{$jobstepid};
  delete $reader{$jobstepid};
  delete $slot[$proc{$pid}->{slot}]->{pid};
  push @freeslot, $proc{$pid}->{slot};
  delete $proc{$pid};

  $progress_is_dirty = 1;
  1;
}


sub readfrompipes
{
  my $gotsome = 0;
  foreach my $job (keys %reader)
  {
    my $buf;
    while (0 < sysread ($reader{$job}, $buf, 8192))
    {
      print STDERR $buf if $ENV{MR_DEBUG};
      $jobstep[$job]->{stderr} .= $buf;
      $gotsome = 1;
    }
  }
  return $gotsome;
}


sub process_stderr_for_output_key
{
  my $job = shift;
  while ($jobstep[$job]->{stderr} =~ s/\+\+\+mrout (.*?)\+\+\+\n//)
  {
    $jobstep[$job]->{output} = $1;
    $jobsteps_must_output_keys = 1;
  }
}


sub process_stderr
{
  my $job = shift;
  my $success = shift;
  while ($jobstep[$job]->{stderr} =~
	 s/\+\+\+mrjobstep(?:\/(\d+|\*))? (\d+) (.*?)\+\+\+\n//)
  {
    next if !$success;
    my ($merge, $level, $input) = ($1, $2, $3);
    my $newjobref;
    if ($merge)
    {
      push @jobstep_tomerge, $input;
      $jobstep_tomerge_level = $level;
      if ($merge !~ /\D/ && @jobstep_tomerge >= $merge)
      {
	$newjobref = { input => join ("\n",
				      splice @jobstep_tomerge, 0, $merge),
		       level => $level,
		       attempts => 0 };
      }
    }
    else
    {
      $newjobref = { input => $input,
		     level => $level,
		     attempts => 0 };
    }
    if ($newjobref)
    {
      push @jobstep, $newjobref;
      push @jobstep_todo, $#jobstep;
    }
  }
  map {
    Log ($job, "stderr $_");
  } split ("\n", $jobstep[$job]->{stderr});
}


sub killem
{
  foreach (@_)
  {
    my $sig = 2;		# SIGINT first
    if (exists $proc{$_}->{"sent_$sig"} &&
	time - $proc{$_}->{"sent_$sig"} > 4)
    {
      $sig = 15;		# SIGTERM if SIGINT doesn't work
    }
    if (exists $proc{$_}->{"sent_$sig"} &&
	time - $proc{$_}->{"sent_$sig"} > 4)
    {
      $sig = 9;			# SIGKILL if SIGTERM doesn't work
    }
    if (!exists $proc{$_}->{"sent_$sig"})
    {
      Log ($proc{$_}->{jobstep}, "sending 2x signal $sig to pid $_");
      kill $sig, $_;
      select (undef, undef, undef, 0.1);
      if ($sig == 2)
      {
	kill $sig, $_;	   # srun wants two SIGINT to really interrupt
      }
      $proc{$_}->{"sent_$sig"} = time;
      $proc{$_}->{"killedafter"} = time - $proc{$_}->{"time"};
    }
  }
}


sub fhbits
{
  my($bits);
  for (@_) {
    vec($bits,fileno($_),1) = 1;
  }
  $bits;
}


sub Log				# ($jobstep_id, $logmessage)
{
  my $fh = select STDERR; $|=1; select $fh;
  my $message = sprintf ("%d %d %s %s\n", $job_id, $$, @_);
  print STDERR $message;

  return if !$metastream;
  my @gmtime = gmtime;
  my $datetime = sprintf ("%04d-%02d-%02d_%02d:%02d:%02d",
			  $gmtime[5]+1900, $gmtime[4]+1, @gmtime[3,2,1,0]);
  $metastream->write_data ($datetime . " " . $message);
}


sub croak
{
  my ($package, $file, $line) = caller;
  my $message = "@_ at $file line $line\n";
  Log (undef, $message);
  cleanup() if $dbh;
  save_meta() if $metastream;
  die;
}


sub cleanup
{
  my $sth;
  $sth = $dbh->prepare ("update mrjobmanager set finishtime=now() where id=?");
  $sth->execute ($jobmanager_id);
  $sth = $dbh->prepare ("update mrjob set success=0, finishtime=now() where id=? and jobmanager_id=? and finishtime is null");
  $sth->execute ($job_id, $jobmanager_id);
}


sub save_meta
{
  my $justcheckpoint = shift; # false if this will be the last meta saved
  my $m = $metastream;
  $m = $m->copy if $justcheckpoint;
  $m->write_finish;
  my $key = $m->as_key;
  undef $metastream if !$justcheckpoint; # otherwise Log() will try to use it
  Log (undef, "meta key is $key");
  $dbh->do ("update mrjob set metakey=? where id=?",
	    undef,
	    $key, $job_id);
}


sub freeze
{
  Log (undef, "freeze");

  my $freezer = new Warehouse::Stream (whc => $whc);
  $freezer->clear;
  $freezer->name (".");
  $freezer->write_start ("state.txt");

  $freezer->write_data (join ("\n",
			      "job $Job->{id}",
			      map
			      {
				$_ . "=" . freezequote($Job->{$_})
			      } grep { $_ ne "id" } keys %$Job) . "\n\n");

  foreach my $Jobstep (@jobstep)
  {
    my $str = join ("\n",
		    map
		    {
		      $_ . "=" . freezequote ($Jobstep->{$_})
		    } grep { $_ ne "stderr" } keys %$Jobstep);
    $freezer->write_data ($str."\n\n");
  }
  if (@jobstep_tomerge)
  {
    $freezer->write_data
	("merge $jobstep_tomerge_level "
	 . freezequote (join ("\n",
			      map { freezequote ($_) } @jobstep_tomerge))
	 . "\n\n");
  }

  $freezer->write_finish;
  my $frozentokey = $freezer->as_key;
  undef $freezer;
  Log (undef, "frozento key is $frozentokey");
  $dbh->do ("update mrjob set frozentokey=? where id=?",
	    undef,
	    $frozentokey, $job_id);
  return $frozentokey;
}


sub thaw
{
  my $key = shift;
  Log (undef, "thaw from $key");

  @jobstep = ();
  @jobstep_done = ();
  @jobstep_todo = ();
  @jobstep_tomerge = ();
  $jobstep_tomerge_level = 0;
  my $frozenjob = {};

  my $stream = new Warehouse::Stream ( whc => $whc,
				       hash => [split (",", $key)] );
  $stream->rewind;
  while (my $dataref = $stream->read_until (undef, "\n\n"))
  {
    if ($$dataref =~ /^job /)
    {
      foreach (split ("\n", $$dataref))
      {
	my ($k, $v) = split ("=", $_, 2);
	$frozenjob->{$k} = freezeunquote ($v);
      }
      next;
    }

    if ($$dataref =~ /^merge (\d+) (.*)/)
    {
      $jobstep_tomerge_level = $1;
      @jobstep_tomerge
	  = map { freezeunquote ($_) } split ("\n", freezeunquote($2));
      next;
    }

    my $Jobstep = { };
    foreach (split ("\n", $$dataref))
    {
      my ($k, $v) = split ("=", $_, 2);
      $Jobstep->{$k} = freezeunquote ($v) if $k;
    }
    $Jobstep->{attempts} = 0;
    push @jobstep, $Jobstep;

    if ($Jobstep->{exitcode} eq "0")
    {
      push @jobstep_done, $#jobstep;
    }
    else
    {
      push @jobstep_todo, $#jobstep;
    }
  }

  foreach (qw (mrfunction revision inputkey knobs))
  {
    $Job->{$_} = $frozenjob->{$_};
  }
  $dbh->do ("update mrjob
		 set mrfunction=?, revision=?, input0=?, knobs=?
		 where id=?",
	    undef,
	    $Job->{mrfunction},
	    $Job->{revision},
	    $Job->{inputkey},
	    $Job->{knobs},
	    $Job->{id},
	    );
}


sub freezequote
{
  my $s = shift;
  $s =~ s/\\/\\\\/g;
  $s =~ s/\n/\\n/g;
  return $s;
}


sub freezeunquote
{
  my $s = shift;
  $s =~ s{\\(.)}{$1 eq "n" ? "\n" : $1}ge;
  return $s;
}
