#!/usr/bin/perl

# mrjobmanager: initiate and supervise all map and reduce tasks for one job.
#
# 1. Find lowest reduce task level for this job
# 2. Run all reduce tasks with this lowest level
#    (this may cause more tasks to be queued)
# 3. Repeat from #3 until no tasks remain.

use strict;
use DBI;
use POSIX ':sys_wait_h';
use Fcntl qw(F_GETFL F_SETFL O_NONBLOCK);

do '/etc/polony-tools/config.pl';
my $max_nprocs = 64;



my ($job_id) = @ARGV;



my $dbh = DBI->connect($main::mapreduce_dsn,
		       $main::mapreduce_mysql_username,
		       $main::mapreduce_mysql_password);
die $DBI::errstr if !$dbh;



my $sth = $dbh->prepare ("select nprocs, revision, knobs, mrfunction
                          from mrjob where id=?");
$sth->execute ($job_id) or die $dbh->errstr;
my ($job_nprocs, $job_revision, $job_knobs, $mrfunction) = $sth->fetchrow;



# Claim this job, and make sure nobody else does

$sth = $dbh->prepare ("insert into mrjobmanager
                       (pid, revision, starttime)
                       values (?, ?, now())");
my $rev = q/$Revision: 184 $/;
$rev =~ /\d+/;
$sth->execute ($$, $&) or die $dbh->errstr;

$sth = $dbh->prepare ("select last_insert_id()");
$sth->execute or die $dbh->errstr;
my ($jobmanager_id) = $sth->fetchrow_array;

$sth = $dbh->prepare ("update mrjob set jobmanager_id=?
                       where id=? and jobmanager_id is null");
$sth->execute ($jobmanager_id, $job_id) or die $dbh->errstr;

$sth = $dbh->prepare ("select jobmanager_id from mrjob
                       where id=?");
$sth->execute ($job_id) or die $dbh->errstr;
my ($check_jobmanager_id) = $sth->fetchrow_array;
if ($check_jobmanager_id != $jobmanager_id)
{
  # race condition - another job manager proc stole the job
  exit(1);
}



Log ($dbh, $job_id, undef, "start");



ONELEVEL:

my $tasks_succeeded = 0;
my $tasks_failed = 0;

Log ($dbh, $job_id, undef, "determine current job level");
$sth = $dbh->prepare ("select min(level) from mrjobstep
                       where jobid=?
                       and (finishtime is null or exitcode <> 0)
                       and (attempts < 3)");
$sth->execute ($job_id) or die $dbh->errstr;
my ($level) = $sth->fetchrow;




Log ($dbh, $job_id, undef, "get job step list");

$sth = $dbh->prepare ("select id, input from mrjobstep
                       where jobid=? and level=?
                       and (finishtime is null or exitcode <> 0)
                       and (attempts < 3)");
$sth->execute ($job_id, $level) or die $dbh->errstr;



Log ($dbh, $job_id, undef, "start child processes");

my %proc_job;
my %job_stderr;
my %reader;
my $children = 0;
my ($id, $input);
while (($id, $input) = $sth->fetchrow)
{
  pipe $reader{$id}, "writer" or die "$!";
  my $flags = fcntl ($reader{$id}, F_GETFL, 0) or die "$!";
  fcntl ($reader{$id}, F_SETFL, $flags | O_NONBLOCK) or die "$!";

  my $childpid = fork();
  if ($childpid == 0)
  {
    foreach (values (%reader))
    {
      close($_);
    }
    fcntl ("writer", F_SETFL, 0) or die "$!"; # no close-on-exec
    open(STDOUT,">&writer");
    open(STDERR,">&writer");

    $dbh->{InactiveDestroy} = 1;
    undef $dbh;
    undef $sth;


    $ENV{"MR_ID"} = $id;
    $ENV{"MR_JOB_ID"} = $job_id;
    $ENV{"MR_INPUT"} = $input;
    $ENV{"MR_KNOBS"} = $job_knobs;
    $ENV{"MR_REVISION"} = $job_revision;
    $ENV{"MR_LEVEL"} = $level;
    $ENV{"MR_FUNCTION"} = $mrfunction;
    $ENV{"INSTALL_REPOS"} = $main::svn_repos;
    $ENV{"INSTALL_REVISION"} = $job_revision;
    $ENV{"MOGILEFS_TRACKERS"} = join (",", @main::mogilefs_trackers);
    $ENV{"MOGILEFS_DOMAIN"} = $main::mogilefs_default_domain;
    $ENV{"MOGILEFS_CLASS"} = $main::mogilefs_default_class;

    exec("srun -n1 -D /tmp sh -c '/usr/local/polony-tools/installrevision && /usr/local/polony-tools/$job_revision/src/mapreduce/mrtaskmanager'");
    exit(1);
  }
  close("writer");
  if (!defined $childpid)
  {
    close $reader{$id};
    delete $reader{$id};
    next;
  }
  $proc_job{$childpid} = $id;

  # XXX shouldn't have to reconnect here??? XXX
  $dbh = DBI->connect($main::mapreduce_dsn,
		      $main::mapreduce_mysql_username,
		      $main::mapreduce_mysql_password);
  die $DBI::errstr if !$dbh;

  Log ($dbh, $job_id, $id, "child $childpid started");
  my $start_sth = $dbh->prepare ("update mrjobstep set
                                  attempts=attempts+1,
                                  starttime=now(),
                                  finishtime=null
                                  where id=? and jobid=?");
  $start_sth->execute ($id, $job_id);

  ++$children;
  while ($children >= $job_nprocs ||
	 $children >= $max_nprocs)
  {
    readfrompipes (\%reader, \%proc_job, \%job_stderr);
    
    my $pid = waitpid (-1, WNOHANG);
    if ($pid > 0) {
      Log ($dbh, $job_id, $proc_job{$pid}, "child $pid exit $?");
      if ($?) { ++$tasks_failed; }
      else { ++$tasks_succeeded; }
      my $finish_sth = $dbh->prepare ("update mrjobstep set
                                       finishtime=now(),
                                       exitcode=?,
                                       stderr=?
                                       where id=? and jobid=?");
      $finish_sth->execute ($?,
			    $job_stderr{$proc_job{$pid}},
			    $proc_job{$pid},
			    $job_id);
      close $reader{$proc_job{$pid}};
      delete $reader{$proc_job{$pid}};
      delete $job_stderr{$proc_job{$pid}};
      delete $proc_job{$pid};
      --$children;
    }
  }

  if (($tasks_failed >= 8 && $tasks_succeeded == 0) ||
      ($tasks_failed >= 16 && $tasks_failed > $tasks_succeeded))
  {
    my $message = "Failure rate too high ($tasks_failed/"
	.($tasks_failed+$tasks_succeeded)
	.") -- giving up";
    Log ($dbh, $job_id, undef, $message);
    die $message;
  }
}

Log ($dbh, $job_id, undef, "wait for last $children children to finish");
while ($children > 0)
{
  readfrompipes (\%reader, \%proc_job, \%job_stderr);

  my $pid = waitpid (-1, WNOHANG);
  if ($pid > 0) {
    Log ($dbh, $job_id, $proc_job{$pid}, "child $pid exit $?");
    if ($?) { ++$tasks_failed; }
    else { ++$tasks_succeeded; }
    my $finish_sth = $dbh->prepare ("update mrjobstep set
                                     finishtime=now(),
                                     exitcode=?,
                                     stderr=?
                                     where id=? and jobid=?");
    $finish_sth->execute ($?,
			  $job_stderr{$proc_job{$pid}},
			  $proc_job{$pid},
			  $job_id);
    close $reader{$proc_job{$pid}};
    delete $reader{$proc_job{$pid}};
    delete $job_stderr{$proc_job{$pid}};
    delete $proc_job{$pid};
    --$children;
  }
}

if ($tasks_succeeded > 0)
{
  Log ($dbh, $job_id, undef, "check for new tasks.");
  goto ONELEVEL;
}
elsif ($tasks_failed > 0)
{
  Log ($dbh, $job_id, undef, "stop because $tasks_failed tasks failed.");
  exit 1;
}

Log ($dbh, $job_id, undef, "finish");
exit 0;



sub readfrompipes
{
  my ($reader, $proc_job, $job_stderr) = @_;
  my ($rout, $wout, $eout);
  my ($bits) = fhbits(keys %$reader);
  select ($rout=$bits, $wout, $eout=$bits, 0.1);
  foreach my $job (keys %$reader)
  {
    if (1 || vec($rout,fileno($$reader{$job}),1))
    {
      my $buf;
      while (0 < sysread ($$reader{$job}, $buf, 1024))
      {
	$$job_stderr{$job} .= $buf;
	print STDERR $buf if $ENV{MR_DEBUG};

	while ($job_stderr{$job} =~ s/\+\+\+mrjobstep (\d+) (.*?)\+\+\+\n//)
	{
	  my ($level, $input) = ($1, $2);
	  my $newjobstep_sth = $dbh->prepare ("insert into mrjobstep
          (jobid, level, input) values (?, ?, ?)");
	  $newjobstep_sth->execute ($job_id, $level, $input) or die $dbh->errstr;
	}
      }
    }
  }
}


sub fhbits
{
  my($bits);
  for (@_) {
    vec($bits,fileno($_),1) = 1;
  }
  $bits;
}


sub Log				# ($dbh, $job_id, $jobstep_id, $logmessage)
{
  my $dbh = shift @_;
  select STDERR; $|=1; select STDOUT;
  printf STDERR ("%s %d %s %s %s\n", scalar localtime, $$, @_);
  my $sth = $dbh->prepare ("insert into mrlog (time, jobid, jobstepid, message)
                            values (now(), ?, ?, ?)");
  $sth->execute (@_) or die $dbh->errstr;
}
