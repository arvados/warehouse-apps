#!/usr/bin/perl

# mrjobmanager: initiate and supervise all map and reduce tasks for one job.
#
# 1. Find lowest reduce task level for this job
# 2. Run all reduce tasks with this lowest level
#    (this may cause more tasks to be queued)
# 3. Repeat from #3 until no tasks remain.

use strict;
use DBI;
use POSIX ':sys_wait_h';
use Fcntl qw(F_GETFL F_SETFL O_NONBLOCK);
use Warehouse;

do '/etc/polony-tools/config.pl';
my $max_nprocs = 64;



my ($job_id) = @ARGV;



my $dbh = DBI->connect($main::mapreduce_dsn,
		       $main::mrcontrol_mysql_username,
		       $main::mrcontrol_mysql_password);
die $DBI::errstr if !$dbh;



my $sth = $dbh->prepare ("select nprocs, revision, input0, knobs, mrfunction
                          from mrjob where id=?");
$sth->execute ($job_id) or die $dbh->errstr;
my ($job_nprocs, $job_revision, $input0, $job_knobs, $mrfunction)
    = $sth->fetchrow or die $sth->errstr;

Log ($dbh, $job_id, undef, "rev $job_revision function $mrfunction knobs $job_knobs");



Log ($dbh, $job_id, undef, "check slurm allocation");
my @taskslot;
# Should use $ENV{SLURM_TASKS_PER_NODE} instead of sinfo? (eg. "4(x3),2,4(x2)")
foreach (`sinfo -h --format='%c %N' --nodes='$ENV{SLURM_NODELIST}'`)
{
  my ($ncpus, $slurm_nodelist) = split;
  my @nodelist;
  while ($slurm_nodelist =~ s/^([^\[,]+?(\[.*?\])?)(,|$)//)
  {
    my $nodelist = $1;
    if ($nodelist =~ /\[((\d+)(-(\d+))?(,(\d+)(-(\d+))?)*)\]/)
    {
      my $ranges = $1;
      foreach (split (",", $ranges))
      {
	my ($a, $b);
	if (/(\d+)-(\d+)/)
	{
	  $a = $1;
	  $b = $2;
	}
	else
	{
	  $a = $_;
	  $b = $_;
	}
	push @nodelist, map {
	  my $n = $nodelist;
	  $n =~ s/\[[-,\d]+\]/$_/;
	  $n;
	} ($a..$b);
      }
    }
    else
    {
      push @nodelist, $nodelist;
    }
  }
  foreach my $node (@nodelist)
  {
    Log ($dbh, $job_id, undef, "node $node - $ncpus slots");
    foreach my $cpu (1..$ncpus)
    {
      push @taskslot, { node => $node,
			cpu => $cpu };
    }
  }
}



# Claim this job, and make sure nobody else does

$sth = $dbh->prepare ("insert into mrjobmanager
                       (pid, revision, starttime)
                       values (?, ?, now())");
my $rev = q/$Revision: 184 $/;
$rev =~ /\d+/;
$sth->execute ($$, $&) or die $dbh->errstr;

$sth = $dbh->prepare ("select last_insert_id()");
$sth->execute or die $dbh->errstr;
my ($jobmanager_id) = $sth->fetchrow_array;

$sth = $dbh->prepare ("update mrjob set jobmanager_id=?, starttime=now()
                       where id=? and jobmanager_id is null");
$sth->execute ($jobmanager_id, $job_id) or croak ($dbh->errstr);

$sth = $dbh->prepare ("select jobmanager_id from mrjob
                       where id=?");
$sth->execute ($job_id) or croak ($dbh->errstr);
my ($check_jobmanager_id) = $sth->fetchrow_array;
if ($check_jobmanager_id != $jobmanager_id)
{
  # race condition - another job manager proc stole the job
  exit(1);
}



Log ($dbh, $job_id, undef, "start");
$SIG{'INT'} = \&croak;
$SIG{'QUIT'} = \&croak;
$SIG{'TERM'} = \&croak;
my $time_slowest_success = 60;	# always reasonable to allow this long



ONELEVEL:

my $tasks_succeeded = 0;
my $tasks_failed = 0;

Log ($dbh, $job_id, undef, "determine current jobstep level");
$sth = $dbh->prepare ("select min(level) from mrjobstep
                       where jobid=?
                       and (finishtime is null or exitcode <> 0)");
$sth->execute ($job_id) or croak ($dbh->errstr);
my ($level) = $sth->fetchrow;
Log ($dbh, $job_id, undef, "start level $level");




Log ($dbh, $job_id, undef, "ask db for jobstep list");

$sth = $dbh->prepare ("select id, input, attempts from mrjobstep
                       where jobid=? and level=?
                       and (finishtime is null or exitcode <> 0)
                       order by id");
$sth->execute ($job_id, $level) or croak ($dbh->errstr);



Log ($dbh, $job_id, undef, "process jobsteps");

my %proc_job;
my %proc_slot;
my %proc_time;
my @freeslot = (0..$#taskslot);
my %job_stderr;
my %job_output;
my %reader;
my ($id, $input, $attempts);
while (($id, $input, $attempts) = $sth->fetchrow)
{
  if ($attempts > 4)
  {
    croak ("jobstep $id failed $attempts times -- giving up");
  }
  pipe $reader{$id}, "writer" or croak ($!);
  my $flags = fcntl ($reader{$id}, F_GETFL, 0) or croak ($!);
  fcntl ($reader{$id}, F_SETFL, $flags | O_NONBLOCK) or croak ($!);

  my $childslot = $freeslot[0];
  my $childnode = $taskslot[$childslot]->{node};
  my $childpid = fork();
  if ($childpid == 0)
  {
    $SIG{'INT'} = 'DEFAULT';
    $SIG{'QUIT'} = 'DEFAULT';
    $SIG{'TERM'} = 'DEFAULT';

    foreach (values (%reader))
    {
      close($_);
    }
    fcntl ("writer", F_SETFL, 0) or croak ($!); # no close-on-exec
    open(STDOUT,">&writer");
    open(STDERR,">&writer");

    $dbh->{InactiveDestroy} = 1;
    undef $dbh;
    undef $sth;


    $ENV{"MR_ID"} = $id;
    $ENV{"MR_JOB_ID"} = $job_id;
    $ENV{"MR_INPUT"} = $input;
    $ENV{"MR_KNOBS"} = $job_knobs;
    $ENV{"MR_REVISION"} = $job_revision;
    $ENV{"MR_LEVEL"} = $level;
    $ENV{"MR_FUNCTION"} = $mrfunction;
    $ENV{"MR_INPUT0"} = $input0;
    $ENV{"MR_OUTPUTKEY"} = "mrjobstep/$job_id/$level/$id";
    $ENV{"INSTALL_REPOS"} = $main::svn_repos;
    $ENV{"INSTALL_REVISION"} = $job_revision;
    $ENV{"MOGILEFS_TRACKERS"} = join (",", @main::mogilefs_trackers);
    $ENV{"MOGILEFS_DOMAIN"} = $main::mogilefs_default_domain;
    $ENV{"MOGILEFS_CLASS"} = $main::mogilefs_default_class;

    my $execstr = "srun --nodelist='$childnode' -n1 -c1 -N1 -D /tmp --job-name='mr$job_id.$id' sh -c '/usr/local/polony-tools/installrevision && /usr/local/polony-tools/$job_revision/src/mapreduce/mrtaskmanager'";
    print STDERR ("$execstr\n") if $ENV{MR_DEBUG};
    exec($execstr);
    exit(1);
  }
  close("writer");
  if (!defined $childpid)
  {
    close $reader{$id};
    delete $reader{$id};
    next;
  }
  shift @freeslot;
  $proc_job{$childpid} = $id;
  $proc_time{$childpid} = time;
  $proc_slot{$childpid} = $childslot;
  # assert (!exists $taskslot[$childslot]->{pid});
  $taskslot[$childslot]->{pid} = $childpid;

  # XXX shouldn't have to reconnect here??? XXX
  $dbh = DBI->connect($main::mapreduce_dsn,
		      $main::mrcontrol_mysql_username,
		      $main::mrcontrol_mysql_password);
  croak ($DBI::errstr) if !$dbh;

  Log ($dbh, $job_id, $id, "child $childpid started on "
       .$taskslot[$childslot]->{node}
       ."."
       .$taskslot[$childslot]->{cpu});
  my $start_sth = $dbh->prepare ("update mrjobstep set
                                  attempts=attempts+1,
                                  starttime=now(),
                                  finishtime=null,
                                  node=?
                                  where id=? and jobid=?");
  $start_sth->execute ($childnode, $id, $job_id);

  while (!@freeslot)
  {
    my $gotsome = readfrompipes (\%reader, \%proc_job, \%job_stderr, \%job_output);
    
    my $pid = waitpid (-1, WNOHANG);
    if ($pid > 0) {
      $gotsome = 1;
      my $whatslot = ($taskslot[$proc_slot{$pid}]->{node}
		      . "."
		      . $taskslot[$proc_slot{$pid}]->{cpu});
      my $jobstepid = $proc_job{$pid};
      Log ($dbh, $job_id, $jobstepid, "child $pid on $whatslot exit $?");
      if ($?) {
	++$tasks_failed;
      }
      else {
	++$tasks_succeeded;
	my $elapsed = time - $proc_time{$pid};
	$time_slowest_success = $elapsed
	    if $time_slowest_success < $elapsed;
      }
      my $finish_sth = $dbh->prepare ("update mrjobstep set
                                       finishtime=now(),
                                       exitcode=?,
				       output=?,
                                       stderr=?
                                       where id=? and jobid=?");
      $finish_sth->execute ($?,
			    $job_output{$jobstepid},
			    $job_stderr{$jobstepid},
			    $jobstepid,
			    $job_id);
      close $reader{$jobstepid};
      delete $reader{$jobstepid};
      delete $job_output{$jobstepid};
      delete $job_stderr{$jobstepid};
      delete $proc_job{$pid};
      delete $proc_time{$pid};
      delete $taskslot[$proc_slot{$pid}]->{pid};
      push @freeslot, $proc_slot{$pid};
      delete $proc_slot{$pid};
    }

    select (undef, undef, undef, 0.1) if !$gotsome;
  }

  if (($tasks_failed >= 8 && $tasks_succeeded == 0) ||
      ($tasks_failed >= 16 && $tasks_failed > $tasks_succeeded))
  {
    my $message = "Failure rate too high ($tasks_failed/"
	.($tasks_failed+$tasks_succeeded)
	.") -- giving up on this round";
    Log ($dbh, $job_id, undef, $message);
    last;
  }
}

Log ($dbh, $job_id, undef, "wait for last ".(scalar keys %proc_job)." children to finish");
while (%proc_job)
{
  my $gotsome = readfrompipes (\%reader, \%proc_job, \%job_stderr, \%job_output);

  my $pid = waitpid (-1, WNOHANG);
  if ($pid > 0) {
    $gotsome = 1;
    my $whatslot = ($taskslot[$proc_slot{$pid}]->{node}
		    . "."
		    . $taskslot[$proc_slot{$pid}]->{cpu});
    my $jobstepid = $proc_job{$pid};
    Log ($dbh, $job_id, $jobstepid, "child $pid on $whatslot exit $?");
    if ($?) {
      ++$tasks_failed;
    }
    else {
      ++$tasks_succeeded;
      my $elapsed = time - $proc_time{$pid};
      $time_slowest_success = $elapsed
	  if $time_slowest_success < $elapsed;
    }
    my $finish_sth = $dbh->prepare ("update mrjobstep set
                                     finishtime=now(),
                                     exitcode=?,
                                     output=?,
                                     stderr=?
                                     where id=? and jobid=?");
    $finish_sth->execute ($?,
			  $job_output{$jobstepid},
			  $job_stderr{$jobstepid},
			  $jobstepid,
			  $job_id);
    close $reader{$jobstepid};
    delete $reader{$jobstepid};
    delete $job_output{$jobstepid};
    delete $job_stderr{$jobstepid};
    delete $proc_job{$pid};
    delete $proc_time{$pid};
    delete $taskslot[$proc_slot{$pid}]->{pid};
    push @freeslot, $proc_slot{$pid};
    delete $proc_slot{$pid};
  }

  if (!$gotsome)
  {
    # nothing better to do
    if ($tasks_succeeded > keys %proc_job)
    {
      # enough jobsteps have succeeded that $time_slowest_success might
      # be meaningful
      if (@taskslot >= 2 * keys %proc_job)
      {
	# at least half of our task slots (cpus) are idle
	for (grep { $proc_time{$_} + $time_slowest_success * 2 < time }
	    keys %proc_time)
	{
	  # pid $_ has taken more than twice as long as the longest
	  # successful job in this round.  It's probably hung.  Kill
	  # it, and restart it in the next round.

	  Log ($dbh, $job_id, $proc_job{$_}, "sending SIGINT x 2 to pid $_");
	  kill 2, $_;
	  select (undef, undef, undef, 0.1);
	  kill 2, $_;
	}
      }
    }
    select (undef, undef, undef, 0.1);
  }
}



# this should ensure that we terminate even if some jobs really
# do take many times longer

$time_slowest_success = $time_slowest_success * 2;

if ($tasks_succeeded > 0 || ($tasks_failed > 0 && $tasks_failed < 5))
{
  Log ($dbh, $job_id, undef, "check for new tasks.");
  goto ONELEVEL;
}
elsif ($tasks_failed > 0)
{
  my $message = "stop because $tasks_failed tasks failed and none succeeded";
  Log ($dbh, $job_id, undef, $message);
  croak ($message);
}



Log ($dbh, $job_id, undef, "reduce");

my $whc = new Warehouse or die "failed to create Warehouse client";

$sth = $dbh->prepare ("select max(level) from mrjobstep
                       where jobid=?");
$sth->execute ($job_id) or croak ($dbh->errstr);
my ($maxlevel) = $sth->fetchrow;

$whc->write_start (1);
$sth = $dbh->prepare ("select output from mrjobstep
                       where jobid=? and level=?
		       order by id");
$sth->execute ($job_id, $maxlevel) or croak ($dbh->errstr);
while (my ($output) = $sth->fetchrow)
{
  $whc->write_data ($whc->fetch_block ($output) or die "fetch_block failed");
}
my $key = $whc->write_finish;



Log ($dbh, $job_id, undef, "key is $key");

$dbh->do ("update mrjob set output=? where id=?", undef,
	  $key, $job_id)
    or croak ($dbh->errstr);

$whc->store_manifest_name ($key, undef, "/job$job_id")
    or croak ($whc->errstr);



Log ($dbh, $job_id, undef, "finish");

$sth = $dbh->prepare ("update mrjob set finishtime=now(), success=1
                       where id=? and jobmanager_id=?");
$sth->execute ($job_id, $jobmanager_id) or croak ($dbh->errstr);

exit 0;



sub readfrompipes
{
  my ($reader, $proc_job, $job_stderr, $job_output) = @_;
  my $gotsome = 0;
  foreach my $job (keys %$reader)
  {
    my $buf;
    while (0 < sysread ($$reader{$job}, $buf, 1024))
    {
      $gotsome = 1;
      $$job_stderr{$job} .= $buf;
      print STDERR $buf if $ENV{MR_DEBUG};

      while ($$job_stderr{$job} =~ s/\+\+\+mrjobstep (\d+) (.*?)\+\+\+\n//)
      {
	my ($level, $input) = ($1, $2);
	my $newjobstep_sth = $dbh->prepare ("insert into mrjobstep
          (jobid, level, input, submittime) values (?, ?, ?, now())");
	$newjobstep_sth->execute ($job_id, $level, $input)
	    or croak ($dbh->errstr);
      }
      while ($$job_stderr{$job} =~ s/\+\+\+mrout (.*?)\+\+\+\n//)
      {
	$$job_output{$job} = $1;
      }
    }
  }
  return $gotsome;
}


sub fhbits
{
  my($bits);
  for (@_) {
    vec($bits,fileno($_),1) = 1;
  }
  $bits;
}


sub Log				# ($dbh, $job_id, $jobstep_id, $logmessage)
{
  my $dbh = shift @_;
  select STDERR; $|=1; select STDOUT;
  printf STDERR ("%s %d %s %s %s\n", scalar localtime, $$, @_);
  my $sth = $dbh->prepare ("insert into mrlog (time, jobid, jobstepid, message)
                            values (now(), ?, ?, ?)");
  $sth->execute (@_) or croak ($dbh->errstr);
}


sub croak
{
  cleanup() if $dbh;
  my ($package, $file, $line) = caller;
  die "$_[0] at $file line $line\n";
}


sub cleanup
{
  my $sth;
  $sth = $dbh->prepare ("update mrjobmanager set finishtime=now() where id=?");
  $sth->execute ($jobmanager_id);
  $sth = $dbh->prepare ("update mrjob set success=0, finishtime=now() where id=? and jobmanager_id=? and finishtime is null");
  $sth->execute ($job_id, $jobmanager_id);
}
