#!/usr/bin/perl
# -*- mode: perl; perl-indent-level: 2; -*-

# mrjobmanager: initiate and supervise all map and reduce tasks for one job.
#
# 1. Find lowest reduce task level for this job
# 2. Run all reduce tasks with this lowest level
#    (this may cause more tasks to be queued)
# 3. Repeat from #3 until no tasks remain.

use strict;
use DBI;
use POSIX ':sys_wait_h';
use Fcntl qw(F_GETFL F_SETFL O_NONBLOCK);
use Warehouse;
use Warehouse::Stream;

do '/etc/polony-tools/config.pl';



$SIG{'USR1'} = sub
{
  $main::ENV{MR_DEBUG} = 1;
};
$SIG{'USR2'} = sub
{
  $main::ENV{MR_DEBUG} = 0;
};



my ($job_id) = @ARGV;



my $dbh = DBI->connect($main::mapreduce_dsn,
		       $main::mrcontrol_mysql_username,
		       $main::mrcontrol_mysql_password);
die $DBI::errstr if !$dbh;



my $whc = new Warehouse or die "failed to create Warehouse client";
my $metastream = new Warehouse::Stream (whc => $whc);
$metastream->clear;
$metastream->name (".");
$metastream->write_start ("log.txt");



my $sth = $dbh->prepare ("select nprocs, revision, input0, knobs, mrfunction
                          from mrjob where id=?");
$sth->execute ($job_id) or die $dbh->errstr;
my ($job_nprocs, $job_revision, $input0, $job_knobs, $mrfunction)
    = $sth->fetchrow or die $sth->errstr;

Log (undef, "rev $job_revision function $mrfunction knobs $job_knobs");



Log (undef, "check slurm allocation");
my @taskslot;
# Should use $ENV{SLURM_TASKS_PER_NODE} instead of sinfo? (eg. "4(x3),2,4(x2)")
foreach (`sinfo -h --format='%c %N' --nodes='$ENV{SLURM_NODELIST}'`)
{
  my ($ncpus, $slurm_nodelist) = split;
  my @nodelist;
  while ($slurm_nodelist =~ s/^([^\[,]+?(\[.*?\])?)(,|$)//)
  {
    my $nodelist = $1;
    if ($nodelist =~ /\[((\d+)(-(\d+))?(,(\d+)(-(\d+))?)*)\]/)
    {
      my $ranges = $1;
      foreach (split (",", $ranges))
      {
	my ($a, $b);
	if (/(\d+)-(\d+)/)
	{
	  $a = $1;
	  $b = $2;
	}
	else
	{
	  $a = $_;
	  $b = $_;
	}
	push @nodelist, map {
	  my $n = $nodelist;
	  $n =~ s/\[[-,\d]+\]/$_/;
	  $n;
	} ($a..$b);
      }
    }
    else
    {
      push @nodelist, $nodelist;
    }
  }
  foreach my $node (@nodelist)
  {
    Log (undef, "node $node - $ncpus slots");
    foreach my $cpu (1..$ncpus)
    {
      push @taskslot, { node => $node,
			cpu => $cpu };
    }
  }
}



# Claim this job, and make sure nobody else does

$sth = $dbh->prepare ("insert into mrjobmanager
                       (pid, revision, starttime)
                       values (?, ?, now())");
my $rev = q/$Revision: 184 $/;
$rev =~ /\d+/;
$sth->execute ($$, $&) or die $dbh->errstr;

$sth = $dbh->prepare ("select last_insert_id()");
$sth->execute or die $dbh->errstr;
my ($jobmanager_id) = $sth->fetchrow_array;

$sth = $dbh->prepare ("update mrjob set jobmanager_id=?, starttime=now()
                       where id=? and jobmanager_id is null");
$sth->execute ($jobmanager_id, $job_id) or croak ($dbh->errstr);

$sth = $dbh->prepare ("select jobmanager_id from mrjob
                       where id=?");
$sth->execute ($job_id) or croak ($dbh->errstr);
my ($check_jobmanager_id) = $sth->fetchrow_array;
if ($check_jobmanager_id != $jobmanager_id)
{
  # race condition - another job manager proc stole the job
  Log (undef,
       "job taken by jobmanager id $check_jobmanager_id");
  exit (1);
}



Log (undef, "start");
$SIG{'INT'} = \&croak;
$SIG{'QUIT'} = \&croak;
$SIG{'TERM'} = \&croak;
my $time_slowest_success = 60;	# always reasonable to allow this long



my $tasks_succeeded_total = 0;
my $tasks_failed_total = 0;



ONELEVEL:

my $tasks_succeeded = 0;
my $tasks_failed = 0;

Log (undef, "determine current jobstep level");
$sth = $dbh->prepare ("select min(level) from mrjobstep
                       where jobid=?
                       and (finishtime is null or exitcode <> 0)");
$sth->execute ($job_id) or croak ($dbh->errstr);
my ($level) = $sth->fetchrow;
Log (undef, "start level $level");



Log (undef, "ask db for jobstep list");

$sth = $dbh->prepare ("select id, input, attempts from mrjobstep
                       where jobid=? and level=?
                       and (finishtime is null or exitcode <> 0)
                       order by id");
$sth->execute ($job_id, $level) or croak ($dbh->errstr);
my $tasks_todo = $sth->rows;
update_progress_stats();



Log (undef, "process jobsteps");

my %proc_job;
my %proc_slot;
my %proc_time;
my @freeslot = (0..$#taskslot);
my %job_stderr;
my %job_output;
my %reader;
my ($id, $input, $attempts);
while (($id, $input, $attempts) = $sth->fetchrow)
{
  if ($attempts > 4)
  {
    croak ("jobstep $id failed $attempts times -- giving up");
  }
  pipe $reader{$id}, "writer" or croak ($!);
  my $flags = fcntl ($reader{$id}, F_GETFL, 0) or croak ($!);
  fcntl ($reader{$id}, F_SETFL, $flags | O_NONBLOCK) or croak ($!);

  my $childslot = $freeslot[0];
  my $childnode = $taskslot[$childslot]->{node};
  my $childpid = fork();
  if ($childpid == 0)
  {
    $SIG{'INT'} = 'DEFAULT';
    $SIG{'QUIT'} = 'DEFAULT';
    $SIG{'TERM'} = 'DEFAULT';

    foreach (values (%reader))
    {
      close($_);
    }
    fcntl ("writer", F_SETFL, 0) or croak ($!); # no close-on-exec
    open(STDOUT,">&writer");
    open(STDERR,">&writer");

    $dbh->{InactiveDestroy} = 1;
    undef $dbh;
    undef $sth;


    $ENV{"MR_ID"} = $id;
    $ENV{"MR_JOB_ID"} = $job_id;
    $ENV{"MR_INPUT"} = $input;
    $ENV{"MR_KNOBS"} = $job_knobs;
    $ENV{"MR_REVISION"} = $job_revision;
    $ENV{"MR_LEVEL"} = $level;
    $ENV{"MR_FUNCTION"} = $mrfunction;
    $ENV{"MR_INPUT0"} = $input0;
    $ENV{"MR_OUTPUTKEY"} = "mrjobstep/$job_id/$level/$id";
    $ENV{"INSTALL_REPOS"} = $main::svn_repos;
    $ENV{"INSTALL_REVISION"} = $job_revision;
    $ENV{"MOGILEFS_TRACKERS"} = join (",", @main::mogilefs_trackers);
    $ENV{"MOGILEFS_DOMAIN"} = $main::mogilefs_default_domain;
    $ENV{"MOGILEFS_CLASS"} = $main::mogilefs_default_class;

    my $execstr = "srun --nodelist='$childnode' -n1 -c1 -N1 -D /tmp --job-name='mr$job_id.$id' sh -c '/usr/local/polony-tools/installrevision && /usr/local/polony-tools/$job_revision/src/mapreduce/mrtaskmanager'";
    print STDERR ("$execstr\n") if $ENV{MR_DEBUG};
    exec($execstr);
    exit(1);
  }
  close("writer");
  if (!defined $childpid)
  {
    close $reader{$id};
    delete $reader{$id};
    next;
  }
  shift @freeslot;
  $proc_job{$childpid} = $id;
  $proc_time{$childpid} = time;
  $proc_slot{$childpid} = $childslot;
  # assert (!exists $taskslot[$childslot]->{pid});
  $taskslot[$childslot]->{pid} = $childpid;

  # XXX shouldn't have to reconnect here??? XXX
  $dbh = DBI->connect($main::mapreduce_dsn,
		      $main::mrcontrol_mysql_username,
		      $main::mrcontrol_mysql_password);
  croak ($DBI::errstr) if !$dbh;

  Log ($id, "child $childpid started on "
       .$taskslot[$childslot]->{node}
       ."."
       .$taskslot[$childslot]->{cpu});
  my $start_sth = $dbh->prepare ("update mrjobstep set
                                  attempts=attempts+1,
                                  starttime=now(),
                                  finishtime=null,
                                  node=?
                                  where id=? and jobid=?");
  $start_sth->execute ($childnode, $id, $job_id);
  --$tasks_todo;
  update_progress_stats();

  while (!@freeslot)
  {
    my $gotsome
	= readfrompipes ()
	+ reapchildren ();
    select (undef, undef, undef, 0.1) if !$gotsome;
  }

  if (($tasks_failed >= 8 && $tasks_succeeded == 0) ||
      ($tasks_failed >= 16 && $tasks_failed > $tasks_succeeded))
  {
    my $message = "Failure rate too high ($tasks_failed/"
	.($tasks_failed+$tasks_succeeded)
	.") -- giving up on this round";
    Log (undef, $message);
    last;
  }
}

Log (undef, "wait for last ".(scalar keys %proc_job)." children to finish");
while (%proc_job)
{
  my $gotsome
      = readfrompipes ()
      + reapchildren ();

  if ($gotsome)
  {
    update_progress_stats();
  }
  else
  {
    # nothing better to do
    if ($tasks_succeeded > keys %proc_job)
    {
      # enough jobsteps have succeeded that $time_slowest_success might
      # be meaningful
      if (@taskslot >= 2 * keys %proc_job)
      {
	# at least half of our task slots (cpus) are idle
	for (grep { $proc_time{$_} + $time_slowest_success * 2 < time }
	    keys %proc_time)
	{
	  # pid $_ has taken more than twice as long as the longest
	  # successful job in this round.  It's probably hung.  Kill
	  # it, and restart it in the next round.

	  Log ($proc_job{$_}, "sending SIGINT x 2 to pid $_");
	  kill 2, $_;
	  select (undef, undef, undef, 0.1);
	  kill 2, $_;
	}
      }
    }
    select (undef, undef, undef, 0.1);
  }
}

update_progress_stats();



# this should ensure that we terminate even if some jobs really
# do take many times longer

$time_slowest_success = $time_slowest_success * 2;

if ($tasks_succeeded > 0 || ($tasks_failed > 0 && $tasks_failed < 5))
{
  Log (undef, "check for new tasks.");
  goto ONELEVEL;
}
elsif ($tasks_failed > 0)
{
  my $message = "stop because $tasks_failed tasks failed and none succeeded";
  Log (undef, $message);
  croak ($message);
}



my $success = 1;



Log (undef, "reduce");

$sth = $dbh->prepare ("select max(level) from mrjobstep
                       where jobid=?");
$sth->execute ($job_id) or croak ($dbh->errstr);
my ($maxlevel) = $sth->fetchrow;

$whc->write_start (1);
$sth = $dbh->prepare ("select output from mrjobstep
                       where jobid=? and level=? and output is not null
		       order by id");
$sth->execute ($job_id, $maxlevel) or croak ($dbh->errstr);
while (my ($output) = $sth->fetchrow)
{
  if (my $outblock = $whc->fetch_block ($output))
  {
    $whc->write_data ($outblock);
  }
  else
  {
    $whc->write_data ("XXX fetch_block($output) failed XXX\n");
    $success = 0;
  }
}
my $key = $whc->write_finish;



if ($key)
{
    Log (undef, "output key is $key");

    $dbh->do ("update mrjob set output=? where id=?", undef,
	      $key, $job_id)
	or croak ($dbh->errstr);

    $whc->store_manifest_by_name ($key, undef, "/job$job_id")
	or croak ($whc->errstr);
}
else
{
    Log (undef, "no output key");
}



Log (undef, "finish");

$sth = $dbh->prepare ("update mrjob set finishtime=now(), success=?
                       where id=? and jobmanager_id=?");
$sth->execute ($success, $job_id, $jobmanager_id)
    or croak ($dbh->errstr);

$metastream->write_finish;
$dbh->do ("update mrjob set metakey=? where id=?",
	  undef,
	  $metastream->as_key, $job_id);
exit 0;



sub update_progress_stats
{
  my $tasks_running = scalar @taskslot - scalar @freeslot;
  $dbh->do
      ("update mrjob set steps_todo=?,steps_done=?,steps_running=? where id=?",
       undef,
       $tasks_todo, $tasks_succeeded_total, $tasks_running, $job_id);
  Log (undef,
       "status $tasks_todo todo $tasks_succeeded_total done $tasks_running running");
}



sub reapchildren
{
  my $pid = waitpid (-1, WNOHANG);
  return 0 if $pid <= 0;

  my $whatslot = ($taskslot[$proc_slot{$pid}]->{node}
		  . "."
		  . $taskslot[$proc_slot{$pid}]->{cpu});
  my $jobstepid = $proc_job{$pid};
  Log ($jobstepid, "child $pid on $whatslot exit $?");
  if ($?) {
    ++$tasks_todo;
    ++$tasks_failed;
    ++$tasks_failed_total;
  }
  else {
    ++$tasks_succeeded;
    ++$tasks_succeeded_total;
    my $elapsed = time - $proc_time{$pid};
    $time_slowest_success = $elapsed
	if $time_slowest_success < $elapsed;
  }
  my $finish_sth = $dbh->prepare
      ("update mrjobstep set
	finishtime=now(),
	exitcode=?,
	output=?,
	stderr=?
	where id=? and jobid=?");
  $finish_sth->execute ($?,
			$job_output{$jobstepid},
			$job_stderr{$jobstepid},
			$jobstepid,
			$job_id);
  map {
    Log ($jobstepid, "stderr $_");
  } split ("\n", $job_stderr{$jobstepid});

  close $reader{$jobstepid};
  delete $reader{$jobstepid};
  delete $job_output{$jobstepid};
  delete $job_stderr{$jobstepid};
  delete $proc_job{$pid};
  delete $proc_time{$pid};
  delete $taskslot[$proc_slot{$pid}]->{pid};
  push @freeslot, $proc_slot{$pid};
  delete $proc_slot{$pid};
  1;
}


sub readfrompipes
{
  my $gotsome = 0;
  foreach my $job (keys %reader)
  {
    my $buf;
    while (0 < sysread ($reader{$job}, $buf, 1024))
    {
      $gotsome = 1;
      $job_stderr{$job} .= $buf;
      print STDERR $buf if $ENV{MR_DEBUG};

      while ($job_stderr{$job} =~ s/\+\+\+mrjobstep (\d+) (.*?)\+\+\+\n//)
      {
	my ($level, $input) = ($1, $2);
	my $newjobstep_sth = $dbh->prepare ("insert into mrjobstep
          (jobid, level, input, submittime) values (?, ?, ?, now())");
	$newjobstep_sth->execute ($job_id, $level, $input)
	    or croak ($dbh->errstr);
	++$tasks_todo;
      }
      while ($job_stderr{$job} =~ s/\+\+\+mrout (.*?)\+\+\+\n//)
      {
	$job_output{$job} = $1;
      }
    }
  }
  return $gotsome;
}


sub fhbits
{
  my($bits);
  for (@_) {
    vec($bits,fileno($_),1) = 1;
  }
  $bits;
}


sub Log				# ($jobstep_id, $logmessage)
{
  my $fh = select STDERR; $|=1; select $fh;
  my $message = sprintf ("%d %d %s %s\n", $job_id, $$, @_);
  print STDERR $message;

  return if !$metastream;
  my $datetime = sprintf ("%04d-%02d-%02d_%02d:%02d:%02d",
			  (gmtime)[5]+1900, (gmtime)[4,3,2,1,0]);
  $metastream->write_data ($datetime . " " . $message);
}


sub croak
{
  cleanup() if $dbh;
  my ($package, $file, $line) = caller;
  die "$_[0] at $file line $line\n";
}


sub cleanup
{
  my $sth;
  $sth = $dbh->prepare ("update mrjobmanager set finishtime=now() where id=?");
  $sth->execute ($jobmanager_id);
  $sth = $dbh->prepare ("update mrjob set success=0, finishtime=now() where id=? and jobmanager_id=? and finishtime is null");
  $sth->execute ($job_id, $jobmanager_id);
}
