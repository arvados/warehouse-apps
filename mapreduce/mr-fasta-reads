#!/usr/bin/perl
# -*- mode: perl; perl-indent-level: 2; -*-

###MR_DESCRIPTION:visit all subdirectories and generate samples  
###MR_INPUT:manifest
###MR_KNOBS:N=4
###MR_KNOBS:MER=8
###MR_KNOBS:READ_LENGTH=18 
###MR_KNOBS:SEED=12345
###MR_KNOBS:READS=1000000

use strict; 
use Warehouse;
use Warehouse::Manifest;
use Warehouse::Stream;
use IO::Uncompress::Gunzip qw(gunzip $GunzipError);
use Digest::SHA qw(sha512);

my $manifestkey = $ENV{MR_INPUT0};

my $mer = $ENV{KNOB_MER}; 
my $read_length = $ENV{KNOB_READ_LENGTH}; 

#setup global variables for "awzprng" 
my $awzprngseed = $ENV{KNOB_SEED}.$ENV{MR_ID};
my $awzprngbits = 0; 
my $awzprngblocks = 0; 
warn "AWZPRNGSEED = $seed";

if ($ENV{MR_LEVEL} == 0)
{
  $ENV{MR_INPUT} = $manifestkey; 
  for(0..$ENV{KNOB_N}-1) 
  { 
    print STDERR "+++mrjobstep 1 $_+++\n"; 
  }
  print STDERR "+++mrout d41d8cd98f00b204e9800998ecf8427e+++\n";
  exit 0;
}
elsif ($ENV{MR_LEVEL} == 1)
{
  my $whc = new Warehouse
      (memcached_size_threshold => $ENV{KNOB_MEMCACHED_SIZE});
  
  my $manifest = new Warehouse::Manifest (whc => $whc,
					  key => $manifestkey);
					
  my $seed = $ENV{KNOB_SEED}.$ENV{JOBID};
  warn "SEED = $seed"; 
  my $seed = sha512($seed);  
  my $rand_blocks = 2**18; #implies 2^21 reads
  my $rand_bits = 512 * $rand_blocks; # implies 8 x 64 bit reads
  my $good_random_data = $seed;
  my $read_mask = 2**21-1; 

  for (my $i = 1; $i < $rand_blocks; $i++) {
     $seed = sha512($seed);
     $good_random_data .= $seed;
  }
  my @reads = unpack ("Q*", $good_random_data);
  undef $good_random_data;
    
  for (my $i=0; $i < @reads; $i++ ) {
    $reads[$i] = ((($reads [$i] % (2*3142044949)) << 28) | $i);
  }
  @reads = sort {$a <=> $b} (@reads);
  
  my $first_pos = $reads[0]>>28;
  my $first_read = $reads[0] & $read_mask; 
  my $last_pos = $reads[@reads-1]>>28;
  my $last_read = $reads[@reads-1] & $read_mask;
      					      
  warn "generated randomness for ".@reads." reads " 
    ."first position is $first_pos (read $first_read) "
    ."last position is $last_pos (read $last_read)\n";
		
  my $bp = 0; 
  my $current_read = 0; 

  $manifest->rewind;

  my $outstream = new Warehouse::Stream (whc => $whc);
  my $name = "./".$ENV{MR_INPUT};
  warn "$name\n"; 
  $outstream->name ($name);
  $outstream->clear;
  $outstream->write_start ("reads.txt"); 

  while (my $instream = $manifest->subdir_next)
  {
    
    while (my ($pos, $size, $filename) = $instream->file_next)
    {
      last if !defined $pos; 
      $instream->seek ($pos); 
      my $reference; 
      if ($filename =~ m/hap|rand/) {
	warn "ignoring $filename"; 
	next; 
      }
      elsif ($filename =~ m/\.fa$/i) 
      {
	my $read;
	my $valid_read; 
	my $overflow_ref; 
	while (my $dataref = $instream->read_until ($pos + $size))
	{
	  $reference = $$dataref; 
	  $reference =~ s/^>.*\n//;
	  $reference =~ s/\n//g;
      
	  #do some work
	  my $bp_start = $bp;
	  $bp += length ($reference); 
	  
	  my $rand_bits = 0; 
	  my $count = 0; 
	  my $bit; 
	  
	  my $current_position = 0; 
      
	  while (1) {
	    if ($rand_bits < 12 ) {
	      $seed = sha512($seed); #generate some more randomness 
	      $rand_bits = 512;
	    }
	    my $small_gap1 = vec ($seed, 512 - $rand_bits--, 1); 
	    my $small_gap2 = vec ($seed, 512 - $rand_bits--, 1);
	    my $orient = vec ($seed, 512 - $rand_bits--, 1);
	    my $big_gap = 0;
	    for (my $i=0; $i < 9; $i++) {
	      $big_gap = $big_gap<<1 | vec ($seed, 512 - $rand_bits--, 1);
	    }
	    
	    $current_position = $reads[$current_read] >> 28; 
	    $current_read++; 
	    
	    if ( ($current_position+7+3+$small_gap1+7+$big_gap+250+7+3+$small_gap2+7) < $bp){
	      my $answer_key = sprintf 
		  (" %X %X %X %X %X %X", 
		   $reads[$current_read] & $read_mask,  
		   $current_position, $orient, 
		   $small_gap1, $big_gap, $small_gap2); 
	      my @readstart;
	      push @readstart, $current_position-$bp_start;
	      push @readstart, $readstart[-1] + 7 + 3 + $small_gap1;
	      push @readstart, $readstart[-1] + 7 + 250 + $big_gap;
	      push @readstart, $readstart[-1] + 7 + 3 + $small_gap2;
	      my $read0 =
		  substr($reference, $readstart[0], 7).
		  substr($reference, $readstart[1], 7).
		  substr($reference, $readstart[2], 7).
		  substr($reference, $readstart[3], 7);
	      $outstream->write_data ($read0.$answer_key."\n");
	      $valid_read++; 
	      $read++; 
	    }
	    else {
	      last; 
	    }
	  }
#	  my $overflow = $bp-$current_position; 
#	  $bp -= $overflow; 
# 	  $overflow_ref = substr
#	      ($reference, $current_position-$bp_start, $overflow); 
	}
	warn ($valid_read."/".$read." in ".$filename." (".$bp.")\n");	
      }
 	

    }
  }
  $outstream->write_finish; 

  #report randomness consumed 
  warn  "AWZPRNGBLOCKS = $awzprngblocks";
 
  my $fragkey = $whc->store_block ($outstream->as_string)
      or die "store_block failed: ".$whc->errstr;
  print STDERR "+++mrout ".$fragkey."+++\n";
  print STDERR $whc->iostats;
 
  exit 0;  
}

sub awzprng {
   my ($bits) = @_;  
   if ( $main::awzprngbits < $bits) {     
     $main::awzprngseed = sha512($main::awzprngseed); 
     $main::awzprngbits = 512; 
     $main::awzprngblocks++; 
   }
   my $rand = 0; 
   for (my $i = 0; $i < $bits; $i++) { 
     $rand = $rand<<1 | vec ($seed, 512 - $rand_bits--, 1); 
   }
   return $rand; 
}
