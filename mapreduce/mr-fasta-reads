#!/usr/bin/perl
# -*- mode: perl; perl-indent-level: 2; -*-

###MR_DESCRIPTION:visit all subdirectories and generate samples from files ending in .fa (gunzip first for .fa.gz)
###MR_INPUT:manifest
###MR_KNOBS:PREFIXBITS=1
###MR_KNOBS:SUFFIXBITS=21 
###MR_KNOBS:K=8
###MR_KNOBS:BP=3142044949
###MR_KNOBS:PLOIDY=2 
###MR_KNOBS:SEED=12345

use strict; 
use Warehouse;
use Warehouse::Manifest;
use Warehouse::Stream;
use IO::Uncompress::Gunzip qw(gunzip $GunzipError);
use Digest::SHA qw(sha512);

my $manifestkey = $ENV{MR_INPUT0};

if ($ENV{MR_LEVEL} == 0)
{
  $ENV{MR_INPUT} = $manifestkey; 
  for(0..(2**$ENV{KNOB_PREFIXBITS})-1) 
  { 
    print STDERR "+++mrjobstep 1 $_+++\n"; 
  }
  print STDERR "+++mrout d41d8cd98f00b204e9800998ecf8427e+++\n";
  exit 0;
}
elsif ($ENV{MR_LEVEL} == 1)
{
  my $whc = new Warehouse
      (memcached_size_threshold => $ENV{KNOB_MEMCACHED_SIZE});
  
  my $manifest = new Warehouse::Manifest (whc => $whc,
					  key => $manifestkey);
	
  my $outstream = new Warehouse::Stream (whc => $whc);
  my $name = "./".$ENV{MR_INPUT}; 
  $outstream->name ($name);
  $outstream->clear;
  $outstream->write_start ("reads.txt"); 

  #setup global variables for "awzprng" 
  $main::awzprngseed = $ENV{KNOB_SEED}.$name;
  $main::awzprngbits = 0; 
  $main::awzprngblocks = 0; 
  print STDERR "AWZPRNGSEED = $main::awzprngseed\n";
		  
  my @reads; 
  my $bits = $ENV{KNOB_PREFIXBITS}+$ENV{KNOB_SUFFIXBITS};

  for (my $i = 0; $i < (2**$ENV{KNOB_SUFFIXBITS}); $i++ ){
    $reads[$i] = ((awzprng(64)%($ENV{KNOB_PLOIDY}*$ENV{KNOB_BP}))<<$bits)|
	$ENV{MR_INPUT} << $ENV{KNOB_SUFFIXBITS}|
	$i;
  }  
  @reads = sort {$a <=> $b} (@reads);
  		
  my $bp = 0; 
  my $current_read = 0; 

  $manifest->rewind; #isn't this already done by "new" above? --AWZ


  my $k = $ENV{KNOB_K}; 

  my $maxreadlength = 18; 
  my $shortoffset = $maxreadlength-2*$k-1; 
  my $longoffset = 750; 

  while (my $instream = $manifest->subdir_next)
  {
    
    while (my ($pos, $size, $filename) = $instream->file_next)
    {
      last if !defined $pos; 
      $instream->seek ($pos); 
      my $reference;
      if ($filename =~ m/hap|rand/) {
	print STDERR "ignoring $filename\n"; 
	next; 
      }
      elsif ($filename =~ s/\.fa\.g?z$//i){
	my $zblob = ""; 
	while (my $dataref = $instream->read_until ($pos + $size))
	{
	  $zblob .= $$dataref; 
	}
	gunzip \$zblob => \$reference or die $GunzipError;	
      }
      elsif ($filename =~ s/\.fa//i) {
	while (my $dataref = $instream->read_until ($pos + $size))
	{
	  $reference .= $$dataref; 
	}
      }
      else {
	next; 
      }    
      my $read;
      my $valid_read; 
     
      $reference =~ s/^>.*\n//;
      $reference =~ s/\n//g;
      
      #do some work
      my $bp_start = $bp;
      $bp += length ($reference); 
	  
      my $rand_bits = 0; 
      my $count = 0; 
      my $bit; 
      
      my $current_position ; 
      
      while ( $current_read < @reads) {
	
	my $small_gap1 = awzprng(1);  
	my $small_gap2 = awzprng(1);
	my $orient = awzprng(1); 
	my $big_gap = awzprng(9); 
	my $readmask = 2**$bits-1; 
	
	$current_position = $reads[$current_read] >> $bits; 
	$current_read++; 
	
	
	if (($current_position+$longoffset+$big_gap+2*$maxreadlength)<$bp){
	  my @readstart;
	  push @readstart,$current_position-$bp_start;
	  push @readstart,$readstart[-1]+$k+$shortoffset+$small_gap1;
	  push @readstart,$readstart[-1]+$k+750+$big_gap;
	  push @readstart,$readstart[-1]+$k+$shortoffset+$small_gap2;
	  
	  my $answer_key = sprintf 
	      (" %X %s %d %d %d %d %d", 
	       $reads[$current_read] & $readmask,
	       $filename,
	       $readstart[0], 
	       $readstart[1] - $readstart[0],
	       $readstart[2] - $readstart[1],
	       $readstart[3] - $readstart[2],
	       $orient); 

	  my $read0 =
	      substr($reference, $readstart[0], $k)." ".
	      substr($reference, $readstart[1], $k)." ".
	      substr($reference, $readstart[2], $k)." ".
	      substr($reference, $readstart[3], $k);

	  if ($orient) {
	    $read0 = revc($read0); 		
	  }
	  
	  $outstream->write_data ($read0.$answer_key."\n");
	  $valid_read++;  
	}
	elsif ($current_position > $bp) {
	  last; 
	}
	$read++;	
      }
      print STDERR "$valid_read / $read in $filename ($bp)\n";     
    }
  }
  $outstream->write_finish; 

  #report randomness consumed 
  print STDERR "used AWZPRNGBLOCKS = $main::awzprngblocks\n";
 
  my $fragkey = $whc->store_block ($outstream->as_string)
      or die "store_block failed: ".$whc->errstr;
  print STDERR "+++mrout ".$fragkey."+++\n";
  print STDERR $whc->iostats;
 
  exit 0;  
}

sub awzprng {
   my ($bits) = @_;  
   if ( $main::awzprngbits < $bits) {     
     $main::awzprngseed = sha512($main::awzprngseed); 
     $main::awzprngbits = 512; 
     $main::awzprngblocks++; 
    }
   my $rand = 0; 
   for (my $i = 0; $i < $bits; $i++) { 
     $rand = $rand<<1|vec($main::awzprngseed,512-$main::awzprngbits--,1);
   }
   return $rand; 
}


sub revc {
  my ($bp) = @_; 
 
  $bp =~s/a/t/gi;
  $bp =~s/c/g/gi;
  $bp =~s/g/c/gi;
  $bp =~s/t/a/gi;

  return reverse $bp; 
}
