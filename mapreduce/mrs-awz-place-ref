#!/usr/bin/perl
# -*- mode: perl; perl-indent-level: 2; -*-

use strict; 

my @numeric2_bp = ( 'a', 'c', 'g', 't'); 
 
my $max_blocks = 1000000; 
$max_blocks = $ENV{KNOB_MAX_BLOCKS} if $ENV{KNOB_MAX_BLOCKS};
 
my $dump_f = $ENV{KNOB_DUMP};
my $ref_key = $ENV{KNOB_REFERENCE}; 
my $prefix = $ENV{MR_ID}-1; 
my $place_ref = \&place0;
$place_ref = \&place1 if $ENV{KNOB_VARIANT};

print STDERR "PREFIX *** $prefix ***\n"; 

my $index; 
my $buf; 

read(STDIN, $index, (2**24+1)*4);
my $count = vec ($index, 2**24, 32);  
read(STDIN, $buf, $count*2);

print STDERR "read index, count = $count\n"; 

if ($dump_f) {
  dump_freq();
}
else {
  place_reads (); 
  dump_placements(); 
}


sub dump_freq {
  my %hash; 

  print STDERR "entering dump frequencies...\n";

  for (my $i = 0; $i < 2**24; $i++ ) {
    my $start = vec($index, $i, 32);
    my $len = vec ($index, $i+1, 32) - $start; 
    $hash{$len}++;
  }
  print "\nFrequencies:\n";
  while ( my ($k, $v) = each %hash ) {  
    $k/=5;
    print "$v $k\n"; 
  }
}

sub dump_placements {
  my %hash_exact;
  my %hash_mer2;
  my %hash_mer3;

  print STDERR "entering dump placements...\n";

  for (my $i = 0; $i < 2**24; $i++ ) {
    my $start = vec($index, $i, 32);
    my $stop = vec ($index, $i+1, 32); 

    for (my $j = $start; $j < $stop; $j+=5) {
      $hash_exact{vec($buf, $j+2, 16)>>12}++;  
      $hash_mer2{vec($buf, $j+3, 16)>>11}++;  
      $hash_mer3{(vec($buf, $j+3, 16)>>6)&0x1F}++;        
    }
  }
  print "exact frequencies\n"; 
  while ( my ($k, $v) = each %hash_exact ) {  
    print "$v $k\n"; 
  }
  print "mer2 frequencies\n"; 
  while ( my ($k, $v) = each %hash_mer2 ) {  
    print "$v $k\n"; 
  }
  print "mer3 frequencies\n"; 
  while ( my ($k, $v) = each %hash_mer3 ) {  
    print "$v $k\n"; 
  }
  my $reads = $count/5; 
  if ($hash_exact{0} != $reads || 
      $hash_mer2{0} != $reads || 
      $hash_mer3{0} != $reads) {
    print STDERR "DECODE ERROR $reads ".
	$hash_exact{0}." ".$hash_mer2{0}." ".$hash_mer3{0}."\n";
  }
}


sub place_reads {
  use Warehouse;
  use Warehouse::Manifest;
  use Warehouse::Stream;

  my $whc = new Warehouse
      (memcached_size_threshold => $ENV{KNOB_MEMCACHED_SIZE});  #needed? 
  
  my $manifest = new Warehouse::Manifest (whc => $whc,
					  key => $ref_key);

  $manifest->rewind; 

  print STDERR "entering place reads... opened $ref_key for input...\n";  
  
  while (my $instream = $manifest->subdir_next ) {
    while (my ($pos, $size, $filename) = $instream->file_next) {
      last if !defined $pos; 
      $instream->seek ($pos); 
      while (my $dataref = $instream->read_until($pos+$size)) {
	if ($max_blocks>0){ 
	  print STDERR $place_ref->($dataref)." "
	      .length($$dataref)." $filename $max_blocks\n";
	}
	$max_blocks--;
      } 
    }  
  }
  print STDERR $whc->iostats; 
}

sub place0 {

  my ($dataref) = @_; 

  my $count = 0; 
  
  my $bp = length ($$dataref); 
  if ($bp % 2) {
    print STDERR "!!! expected even number of bytes; got $bp !!!\n";
    return 0;
  }
  $bp /= 2; 

  my @hash_mers; 
  for (my $i = 750; $i < 1256; $i++) {
    $hash_mers[vec($$dataref, $i, 16)] = $i; #doesn't handle collisions -- fix!
  }
  for (my $i = 0; $i < $bp-1400; $i++){
    my $mer0 = vec($$dataref, $i, 16); 
    

    if ( $mer0>>8 == $prefix) {
        
      foreach my $wobble01 (9..10) {

  	my $mer1 = vec($$dataref, $i+$wobble01, 16);
	my $suffix = ($mer0 << 16 | $mer1) & 0xFFFFFF; 
		  
	my $start = vec ($index, $suffix, 32);
	my $stop = vec ($index, $suffix+1, 32); 

	for (my $j = $start; $j < $stop; $j+=5) {
	  my $mer2 = vec ($buf, $j, 16);  
	  my $mer3 = vec ($buf, $j+1, 16);
	  my $pos2 = $hash_mers[$mer2];
	  my $pos3 = $hash_mers[$mer3]; 
	  
	  my $wobble23 = $pos3-$pos2; 
	  if ( $wobble23 == 9 || $wobble23 == 10) {	    
#	    my $read = convert_mers($mer0, $mer1, $mer2, $mer3); 
	    
#	    my $ref = convert_mers (vec($$dataref, $i, 16),
#				    vec($$dataref, $i+$wobble01, 16),
#				    vec($$dataref, $pos2, 16), 
#				    vec($$dataref, $pos3, 16)); 
	    
#	    print "$read $i ".($i+$wobble01)." $pos2 $pos3\n";
	   
	    #if ((vec ($buf, $j+2, 16) >> 12)  < 15) {
	    #  vec($buf, $j+2, 16)+=4096; 
	    #}
	    $count++;
	  }
	  #if ($pos2 && ((vec ($buf, $j+3, 16) >> 11)  < 31)) {
	  #  vec($buf, $j+3, 16)+=2048; 	  
	  #}
	  #if ($pos3 && (((vec ($buf, $j+3, 16) >> 6) &0x1F)  < 31)) {
	  #  vec($buf, $j+3, 16)+=64; 
	  #}
	}
      }
    }
    $hash_mers[vec($$dataref, $i+750, 16)] = 0; 
    $hash_mers[vec($$dataref, $i+1256, 16)] = $i+1256;
  }  
  return $count; 
}


sub place1 {

  my ($dataref) = @_; 
 
  my $count; 
  for (my $i = 0; $i < length ($$dataref); $i+=2){
    if ( vec($$dataref, $i+1, 16) == $prefix) {


    }	
  }
  return $count; 
}


sub convert_mers {

  my @mers = @_;

  my $read = ""; 
  
  foreach my $mer (@mers) {  
    for (my $j = 14 ; $j >= 0; $j-=2) { 
      $read .= $numeric2_bp[($mer>>$j)&3];
    } 
  }
  return $read; 
}
