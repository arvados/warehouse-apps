#!/usr/bin/perl
# -*- mode: perl; perl-indent-level: 2; -*-

use strict; 
use Warehouse;
use Warehouse::Manifest;
use Warehouse::Stream;

 
my $dump_N = $ENV{"KNOB_DUMP_READS"};
my $ref_key = $ENV{"KNOB_REFERENCE"}; 
my $prefix = $ENV{"MR_ID"}-1; 
my $place_ref = \&place0;
$place_ref = \&place1 if $ENV{"KNOB_VARIANT"};

print STDERR "PREFIX *** $prefix ***\n"; 

my $index; 
my $buf; 

if (2**26 != read(STDIN, $index, 2**26)) {
  die "failed to read 2**26 byte index\n";
}
my $count = vec ($index, 2**24-1, 32);  

if ($count*2 != read(STDIN, $buf, $count*2)) {
  die "failed to read $count reads\n"; 
}

#conceivably exits without consuming all input (eg. if malformed input.)
print STDERR "count = $count\n"; 


if ($dump_N) {
  dump_reads($dump_N);
}
else {
  place_reads (); 
  
}

sub dump_reads {
  my ($dump_N) = @_; 
  my %hash; 

  for (my $i = 0; $i < 2**24; $i++ ) {
    my $start = $i ? vec($index, $i-1, 32) : 0;
    my $len = vec ($index, $i, 32) - $start; 
    $hash{$len}++;
    
    if ($i % $dump_N == 0) {
      for (my $j = 0; $j < $len; $j+=3) {
	print STDOUT
	    vec($buf, $start+$j, 16)." ".
	    vec($buf, $start+$j+1, 16)." ". 
	    vec($buf, $start+$j+2, 16)." ";  
      }
      if ($len) {
	print STDOUT "*** $i\n";
      }
    }  
  } 
  print "\nFrequencies:\n";
  while ( my ($k, $v) = each %hash ) {  
    $k/=3;
    print "$v $k\n"; 
  }
}

sub place_reads {
 
  my $whc = new Warehouse
      (memcached_size_threshold => $ENV{KNOB_MEMCACHED_SIZE});  #needed? 
  
  my $manifest = new Warehouse::Manifest (whc => $whc,
					  key => $ref_key);

  $manifest->rewind; 

  print STDERR "!!! opened $ref_key for input... !!!\n";  
  
  while (my $instream = $manifest->subdir_next) {
    while (my ($pos, $size, $filename) = $instream->file_next) {
      last if !defined $pos; 
      $instream->seek ($pos); 
      my $reference; 
      while (my $dataref = $instream->read_until ($pos+$size)) {
	print $place_ref->($dataref)." ".length($$dataref)." "; 
	print "$filename\n"; 
	exit 0;
      } 
      print "$filename\n"; 
      #exit 0; 
    }  
  }
  print STDERR $whc->iostats; 
}

sub place0 {

  my ($dataref) = @_; 

  my $count = 0; 
  
  my $bp = length ($$dataref); 
  if ($bp % 2) {
    print STDERR "!!! expected even number of bytes; got $bp !!!\n";
    return 0;
  }
  $bp /= 2; 


  my @hash_mers; 
  for (my $i = 750; $i < 1256; $i++) {
    $hash_mers[vec($$dataref, $i, 16)] = $i; #doesn't handle collisions -- fix!
  }
  for (my $i = 0; $i < $bp-1400; $i++){
    my $mer0 = vec($$dataref, $i, 16); 
    
    if ( $mer0>>8 == $prefix) {
      
      my $suffixA = ($mer0 & 0xFF)<< 16; 
      my $suffixB = $suffixA | vec($$dataref, $i+10, 16); 
      $suffixA |= vec($$dataref, $i+9, 16); 
      	  
      my $start = $suffixA ? vec($index, $suffixA-1, 32) : 0;
      my $stop = vec ($index, $suffixA, 32); 
      my $N = $stop - $start; 
      if ($N % 3) {
	print STDERR "!!! expected triples; got $N !!!\n";
	return 0;
      }
      for (my $j = $start; $j <= $stop; $j+=3) {
	my $mer2 = vec ($buf, $j, 16);  
	my $mer3 = vec ($buf, $j+1, 16);
	my $pos2 = $hash_mers[$mer2];
	my $pos3 = $hash_mers[$mer3]; 
	
	if ($pos2 && $pos3) {
	  my $mer1 = $suffixA & 0xFFFF;
	  $count++; 
	}
	#print "$i mer0 ".$i+9." mer1 $pos2 $mer2 $pos3 $mer3\n"; 
	
	#$start = $suffixB ? vec($index, $suffixB-1, 32) : 0;
	#$stop = vec ($index, $suffixB, 32); 
	#$count += ($stop - $start);	
      }
    }
    $hash_mers[vec($$dataref, $i+750, 16)] = 0; 
    $hash_mers[vec($$dataref, $i+1256, 16)] = $i+1256;
  }  
  return $count; 
}

sub place1 {

  my ($dataref) = @_; 
 
  my $count; 
  for (my $i = 0; $i < length ($$dataref); $i+=2){
    if ( vec($$dataref, $i+1, 16) == $prefix) {


    }	
  }
  return $count; 
}
