#!/usr/bin/perl

# mrtaskmanager: run a map or reduce function on one input.

use strict;
use MogileFS::Client;

$ENV{PATH} .= ":/usr/local/polony-tools/$ENV{MR_REVISION}/bin";
$ENV{PATH} .= ":/usr/local/polony-tools/$ENV{MR_REVISION}/src/mapreduce";
$ENV{PERLLIB} .= ":/usr/local/polony-tools/$ENV{MR_REVISION}/src/mapreduce";

# just for backward compatibility -- mrjobmanager should have set this already
$ENV{MR_OUTPUTKEY} = "mrjobstep/$ENV{MR_JOB_ID}/$ENV{MR_LEVEL}/$ENV{MR_ID}"
    if !exists $ENV{MR_OUTPUTKEY};

foreach (split ("\n", $ENV{MR_KNOBS}))
{
  my ($k, $v) = split ("=", $_, 2);
  $ENV{"KNOB_$k"} = $v;
}

my $childpid = open (STDIN, "-|");
die "Fork failed" if !defined $childpid;
if (!$childpid)
{
  # child process
  exec { "mr-$ENV{MR_FUNCTION}" } ("mr-$ENV{MR_FUNCTION}");
  die "mr-$ENV{MR_FUNCTION}: exec returned $?";
}

# parent process

my $fh;
my $mogc;
my $buf;
while (read STDIN, $buf, 65536)
{
  if (!defined $fh)
  {
    my $attempts = 0;
    while (!defined ($fh) && ++$attempts < 5)
    {
      $mogc = eval {
	MogileFS::Client->new
	    (domain => $ENV{MOGILEFS_DOMAIN},
	     hosts => [split(",", $ENV{MOGILEFS_TRACKERS})]);
	};
      $fh = eval {
	$mogc->new_file ($ENV{MR_OUTPUTKEY}, $ENV{MOGILEFS_CLASS});
      };
      last if $fh;
      sleep 1;
    }
    die "MogileFS create failure" if !$fh;
  }
  print $fh $buf;
}
if ($fh)
{
  if (!close $fh)
  {
    die "MogileFS write failed: $!";
  }
}
if (!close STDIN)
{
  die "mr-$ENV{MR_FUNCTION} failed: $!";
}

wait;
if ($?)
{
  exit (($? >> 8) ? ($? >> 8) : 1);
}
