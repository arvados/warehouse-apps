#!/usr/bin/perl

use strict;

my ($revision_default, $reference, $batchesperjob, $outputdir) = @ARGV
    or die qq{
usage: $0 default-revision reference batchesperjob outputdir

example: $0 2036 f4c53b5ea8ed51077c46116b5c591fae 600 .

};

open STDIN, "wh job list |";

my %Job;
my @Job;

my @jobs = <STDIN>;
for (@jobs)
{
    my %have;
    chomp;
    map { /(.*?)=(.*)/; $have{$1} = $2; } split (/, /);
    $Job{$have{id}} = \%have;
}
@Job = sort { $b->{id} <=> $a->{id} } values %Job;

my $header = sprintf (" %-25s %-38s %-38s %-38s\n",
		      qw(species traces megablast megatri-count));
print $header;

my $html = "";
my $all_species_jobs = $header;

my %traces = qw{
    anopheles_gambiae       8acd9332f0b7c299bd435d91cecf7f1e
    callithrix_jacchus      503333295028639b6644654b15e44e4a
    drosophila_melanogaster a1552c0998ae3a6a303502007a623c25
    canis_familiaris        070a9a97d6d4163d554fdd2212b90288
    gallus_gallus           6a8c30801a63c460f01b7fece00bda0e
    homo_sapiens            309cb0a70f3fb773b2d2228c668de767
    mus_musculus            3375774d2b79c637aa514ae7d0bd7784
    pan_troglodytes         79c134434ba2bbc987ec7be7f91e43aa
    takifugu_rubripes       1ab5d567801169762428c444ee7ad2b9
    xenopus_tropicalis      cc2468dc5d437f6c4bd1773f9307704e
};

foreach my $species (sort keys %traces)
{
    my $megablast;
    my $megatri_count;
    my $symlink;
    $megablast = findjob ( { mrfunction => "megablast",
			     revision => [ 2014, ],
			     inputkey => $traces{$species},
			     knobs => join ("\\n",
					    "BATCHSIZE=1000",
					    "FILTER400BP=1",
					    "MAXBATCHESPERJOB=$batchesperjob",
					    "REFERENCE=$reference",
					    "REFERENCEDIR=$species",
					    ),
			   } );
    if ($megablast && $megablast->{outputkey})
    {
	$megatri_count = findjob ( { mrfunction => "awz-stream",
				     revision => [ 2046, ],
				     inputkey => $megablast->{outputkey},
				     knobs => join ("\\n",
						    "FUNCTION=mrs-megatri-count",
						    "M=0-1",
						    "N=1-5",
						    "EXAMPLES=5",
						    "OUTPUTNAME=megatri-count.txt",
						    ),
				   } );
    }
    if ($megatri_count && $megatri_count->{outputkey})
    {
	my $mtrsum = $0;
	$mtrsum =~ s/[^\/]*$/mtr-sum.pl/;
	my $hash = $megatri_count->{outputkey};
	my $sumfile = "$outputdir/mtr-sum-$hash.txt";
	if (!-s $sumfile)
	{
	    system "$mtrsum $hash > $sumfile";
	    if ($?)
	    {
		unlink ("$outputdir/mtr-sum-$hash.txt");
		die "$mtrsum $hash failed: exit $?";
	    }
	}
	$symlink = "$outputdir/mtr-symlink-$species.txt";
	if (-e $symlink && !-l $symlink)
	{
	    die "$symlink is not a symlink";
	}
	unlink ($symlink) if -l $symlink;
	symlink ("mtr-sum-$hash.txt", $symlink)
	    or die "$symlink: $!";

	my $mtrnormalize = $0;
	$mtrnormalize =~ s/[^\/]*$/mtr-normalize.pl/;
	for my $m (0, 1)
	{
	    my $mskip = 1 - $m;
	    system "egrep -v ^$mskip < $symlink | $mtrnormalize > $outputdir/mtr-normalized-$species-m$m.txt";
	    if ($?)
	    {
		die "$mtrnormalize pipe exit $?";
	    }

	    my $mtrgraph = $0;
	    $mtrgraph =~ s/[^\/]*$/mtr-graph.r/;

	    my $Species = $species;
	    $Species =~ s/_/ /;
	    $Species =~ s/\b([a-z])/uc $1/eg;

	    system "R --slave --vanilla --args imagefile='$outputdir/mtr-normalized-$species-m$m.png' infile='$outputdir/mtr-normalized-$species-m$m.txt' organism='$Species' m='$m' < $mtrgraph >/dev/null";
	    if ($?)
	    {
		die "R exit $?";
	    }
	    $html .= "<img src=\"mtr-normalized-$species-m$m.png\">";
	}
	$html .= "<br />\n";
    }
    my $species_jobs = sprintf (" %-25s %-38s %-38s %-38s %s\n",
				$species,
				$traces{$species},
				id_and_output($megablast),
				id_and_output($megatri_count),
				);
    $all_species_jobs .= $species_jobs;
    print $species_jobs;
}

$html .= "<pre>";
$html .= $all_species_jobs;
$html .= "</pre>";

open HTML, ">", $outputdir."/mtr-index.html" or die "create mtr-index.html: $!";
print HTML $html;
close HTML or die "close mtr-index.html: $!";

sub id_and_output
{
    my $job = shift;
    return "" if !$job;
    return $job->{id}."/".$job->{outputkey} if $job->{outputkey};
    my $steps = $job->{steps_done} + $job->{steps_running} + $job->{steps_todo};
    my $pct = $steps==0 ? "" : " (".int(100*$job->{steps_done}/$steps)."%)";
    return $job->{id}."/".$pct;
}

sub findjob
{
    my $want = shift;
    my $failed;
    my $queued;
    for (@Job)
    {
	if ($_->{revision} >= $want->{revision}->[0]
	    && ($_->{revision} <= $want->{revision}->[1] || !$want->{revision}->[1])
	    && $_->{mrfunction} eq $want->{mrfunction}
	    && $_->{knobs} eq $want->{knobs}
	    && $_->{inputkey} eq $want->{inputkey})
	{
	    $queued = $_ unless $queued || $_->{finishtime} || length ($_->{success});
	    $failed = $_ if !$failed && $_->{success} eq '0';
	    return $_ if $_->{outputkey};
	}
    }
    mention_failed_job ($failed) if !$queued && $failed;
    suggest_new_job ($want) if !$queued && !$want->{quiet};
    return $queued;
}

sub suggest_new_job
{
    my $want = shift;
    my $revision = $want->{revision}->[1] || $revision_default;
    my $knobs = $want->{knobs};
    $knobs =~ s/=(.*?)(\\n|$)/='$1' /g;
    print "wh job new nodes=1 photons=1 revision=$revision mrfunction='".$want->{mrfunction}."' inputkey='".$want->{inputkey}."' $knobs\n";
}

sub mention_failed_job
{
    my $job = shift;
    print "# suggest investigating job id=".$job->{id}." -- failed with frozentokey=".$job->{frozentokey}." metakey=".$job->{metakey}."\n";
}
