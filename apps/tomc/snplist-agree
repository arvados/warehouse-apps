#!/usr/bin/perl

use strict;

my @x;
while (@ARGV && $ARGV[0] ne '--') { push @x, shift @ARGV }
shift @ARGV;
my @y = @ARGV or die "usage: $0 snplist sniplist ... -- snplist snplist ...\n";

print "<PRE>";
my @xlists;
printf "%13s", "";
for my $xfile (@x)
{
    printf " %12.12s", unique_part ($xfile, @x);
    push @xlists, readsnplist ($xfile);
}
my @xhash = map { readlink($_) =~ /([0-9a-f]{32})/ || /([0-9a-f]{32})/ } @x;
my @yhash = map { readlink($_) =~ /([0-9a-f]{32})/ || /([0-9a-f]{32})/ } @y;
my @links;
print "\n";
for my $yfile (@y)
{
    printf "%13.13s", unique_part ($yfile, @y);
    my $ylist_orig = readsnplist ($yfile);
    my $yhash = shift @yhash;
    my @xscore;
    my $xhighscore;
    for (my $xi=0; $xi <= $#xlists; $xi++)
    {
	my $xlist_orig = $xlists[$xi];

	my $xlist = [ @$xlist_orig ];
	my $ylist = [ @$ylist_orig ];
	my $score_nocall = 0;
	my $score_yes = 0;
	my $score_no = 0;
	while (@$xlist && @$ylist)
	{
	    my $cmp = $xlist->[0]->[0] cmp $ylist->[0]->[0]
		|| $xlist->[0]->[1] <=> $ylist->[0]->[1];
	    if ($cmp < 0)
	    {
		shift @$xlist;
		++$score_nocall;
	    }
	    elsif ($cmp > 0)
	    {
		shift @$ylist;
		++$score_nocall;
	    }
	    else
	    {
		# same position
		if ($xlist->[0]->[3] eq "N"
		    ||
		    $ylist->[0]->[3] eq "N")
		{
		    ++$score_nocall;
		}
		elsif ($xlist->[0]->[3] eq "X"
		       ||
		       $ylist->[0]->[3] eq "X")
		{
		    ++$score_nocall;
		}
		elsif ($xlist->[0]->[3] eq
		       $ylist->[0]->[3])
		{
		    # same bp at this position
		    ++$score_yes;
		}
		elsif (($xlist->[0]->[3] &
			$ylist->[0]->[3]) != 0)
		{
		    # some overlap in choices
		    ++$score_no;
		}
		else
		{
		    ++$score_no;
		}
		shift @$xlist;
		shift @$ylist;
	    }
	}
	my $score = ($score_yes + $score_no)
	    ? sprintf ("%.2f", 100*$score_yes/($score_yes+$score_no))
	    : "----";
	push @xscore, [$score, $score_yes, $score_no, $score_nocall];
	$xhighscore = $score if $xhighscore < $score;
    }
    for (my $xi=0; $xi <= $#xscore; $xi++)
    {
	my $star = $xscore[$xi]->[0] > $xhighscore*.9;
	printf "%13.13s", ($star ? "*" : " ").$xscore[$xi]->[0];
	if ($star)
	{
	    my $xhash = $xhash[$xi];
	    my $label = &unique_part ($yfile, @y)
		. " / " . &unique_part ($x[$xi], @x);

	    my ($x, $yes, $no, $nocall) = @ { $xscore[$xi] };
	    push @links, qq{$label - $yes <a href="http://genomerator-dev.freelogy.org/pgp10factory/snpdig.cgi/$yhash;agree-$xhash">agree</a> / $no <a href="http://genomerator-dev.freelogy.org/pgp10factory/snpdig.cgi/$yhash;disagree-$xhash">disagree</a> / $nocall <a href="http://genomerator-dev.freelogy.org/pgp10factory/snpdig.cgi/$yhash;nocall-$xhash">NoCall</a>};
	}
    }
    print "\n";
}
print "</pre>";
print "<UL>\n<LI>".join("</LI>\n<LI>", @links)."</LI>\n</UL>";

sub readsnplist
{
    my $file = shift;
    if ($file =~ /^[0-9a-f]{32}/ && !-e $file)
    {
	open STDIN, "-|", "whget", "-r", $file, "-" or die "whget: $!";
	open STDIN, "-|", "gzip", "-cdf" or die "gzip: $!";
    }
    else
    {
	open STDIN, "<", $file or die "$file: $!";
    }
    my @snplist;
    while (<STDIN>)
    {
	chomp;
	my ($chr, $pos, $refbp, $seqbp, $extra) = split (/\t/, $_, 5);
	push @snplist, [$chr, $pos, $refbp, fasta2bin ($seqbp), $extra]
	    if ($pos =~ /^\d+$/ && $refbp =~ /^.$/);
    }
    close STDIN or die "input: $!";
    return [ sort { $a->[0] cmp $b->[0] || $a->[1] <=> $b->[1] } @snplist ];
}

sub fasta2bin
{
    my $fasta = shift;
    return "N" if $fasta =~ /^N/;
    return "X" if $fasta eq "X";
    $fasta =~ tr/a-z/A-Z/;
    $fasta =~ tr/XACMGRSVTWYHKDBN/0123456789abcdef/;
    $fasta = hex($fasta);
    while ($fasta & ~0xf)
    {
	$fasta = ($fasta & 0xf) | ($fasta >> 4);
    }
    return $fasta;
}

sub bin2fasta
{
    my $x = shift;
    $x = sprintf ("%x", $x);
    $x =~ tr/0123456789abcdef/XACMGRSVTWYHKDBN/;
    return $x;
}

sub unique_part
{
    my $this = shift;
    my $thislen = length($this);
    my $ustart = $thislen;
    my $uend = $thislen;
    for (@_)
    {
	$ustart-- while substr ($this, 0, $ustart) ne substr ($_, 0, $ustart);
	$uend-- while $uend && substr ($this, $thislen-$uend) ne substr ($_, length($_)-$uend);
    }
    return substr ($this, $ustart, $thislen - $uend - $ustart);
}
