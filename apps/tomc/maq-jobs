#!/usr/bin/perl

use strict;
use Fcntl ':flock';
use Warehouse;
my $whc = new Warehouse;

my %override;
while ($ARGV[0] =~ /^(.*?)=(.*)$/)
{
    $override{$1} = $2;
    shift @ARGV;
}

@ARGV == 2
    or die qq{
usage: $0 default-revision workdir

example: $0 2322 /var/cache/maq-jobs-workdir

};

my ($revision_default, $workdir) = @ARGV;

my %Job;
my @Job;

my $joblist = $whc->job_list;
for (@$joblist)
{
    $Job{$_->{id}} = $_;
}
@Job = sort { $b->{id} <=> $a->{id} } values %Job;


opendir (D, $workdir) or die "$workdir: $!";
for my $workfile (readdir D)
{
    next if $workfile =~ /\./;
    fillflow ($workfile);
}
closedir D;


my %Flow;
sub fillflow
{
    my $in = shift;
    return $Flow{$in} if $Flow{$in};

    my $flow = $Flow{$in} = {};
    $flow->{json} = {};

    if (-l "$workdir/$in.stored")
    {
	my $inputhash = readlink "$workdir/$in.stored";
	if (!-e "$workdir/$inputhash")
	{
	    open W, ">", "$workdir/$inputhash";
	    close W;
	}
	if (open L, "<", "$workdir/$in.fetched")
	{
	    my ($url) = <L>;
	    my @stat = stat L;
	    my $localmtime = localtime ($stat[9]);
	    $flow->{json}->{message} = "Downloaded from $url at $localmtime";
	}
    }
    elsif (-e "$workdir/$in.isurl")
    {
	if (open L, "<", "$workdir/$in")
	{
	    my ($url) = <L>;
	    if (flock L, LOCK_SH|LOCK_NB)
	    {
		$flow->{json}->{message} = "Source data at $url is queued for downloading.";
		fork_downloader ("$workdir/$in");
	    }
	    else
	    {
		my @stat = stat "$workdir/$in.lock";
		my $localmtime = localtime ($stat[9]);
		$flow->{json}->{message} = "Started downloading from $url at $localmtime.";
	    }
	    close L;
	}
	return;
    }

    $flow->{json}->{input} = { id => $in };
    $flow->{json}->{pipeline} = { label => "maq" };

    $flow->{sol2bfq} = findjob
	( { mrfunction => "sol2bfq",
	    revision => [ 2314, ],
	    inputkey => $in,
	    knobs => makeknobs ("sol2bfq",
				),
	} ) unless $flow->{sol2bfq};
    if ($flow->{sol2bfq} && $flow->{sol2bfq}->{outputkey})
    {
	$flow->{map} = findjob
	    ( { mrfunction => "maq-map",
		revision => [ 2315, ],
		inputkey => $flow->{sol2bfq}->{outputkey},
		knobs => makeknobs
		    ("maq-map",
		     "MAQ_DEB=ec9aba3c23989d66f813589e2d4450db",
		     "REFERENCE=99259f4330907e84fe7253bd4e52dd3e",
		     "REFERENCEFILE=homo_sapiens.bfa",
		     ),
		} ) unless $flow->{map};
    }
    if ($flow->{map} && $flow->{map}->{outputkey})
    {
	$flow->{merge} = findjob
	    ( { mrfunction => "maq-merge",
		revision => [ 2318, ],
		inputkey => $flow->{map}->{outputkey},
		knobs => makeknobs
		    ("maq-merge",
		     "MAQ_DEB=ec9aba3c23989d66f813589e2d4450db",
		     "REFERENCE=99259f4330907e84fe7253bd4e52dd3e",
		     "REFERENCEFILE=homo_sapiens.bfa",
		     ),
		} ) unless $flow->{merge};
    }
    if ($flow->{merge} && $flow->{merge}->{outputkey})
    {
	$flow->{assemble} = findjob
	    ( { mrfunction => "maq-assemble",
		revision => [ 2319, ],
		inputkey => $flow->{merge}->{outputkey},
		knobs => makeknobs
		    ("maq-assemble",
		     "MAQ_DEB=ec9aba3c23989d66f813589e2d4450db",
		     "REFERENCE=99259f4330907e84fe7253bd4e52dd3e",
		     "REFERENCEFILE=homo_sapiens.bfa",
		     ),
		} ) unless $flow->{assemble};
    }
    if ($flow->{assemble} && $flow->{assemble}->{outputkey})
    {
	$flow->{cns2x} = findjob
	    ( { mrfunction => "maq-cns2x",
		revision => [ 2320, ],
		inputkey => $flow->{assemble}->{outputkey},
		stepspernode => 2,
		nodes => 2,
		knobs => makeknobs
		    ("maq-cns2x",
		     "MAQ_DEB=ec9aba3c23989d66f813589e2d4450db",
		     ),
		} ) unless $flow->{cns2x};
	$flow->{indelsoa} = findjob
	    ( { mrfunction => "maq-indelsoa",
		revision => [ 2321, ],
		inputkey => $flow->{assemble}->{outputkey},
		knobs => makeknobs
		    ("maq-indelsoa",
		     "MAQ_DEB=ec9aba3c23989d66f813589e2d4450db",
		     "REFERENCE=99259f4330907e84fe7253bd4e52dd3e",
		     "REFERENCEFILE=homo_sapiens.bfa",
		     ),
		} ) unless $flow->{indelsoa};
    }
    $flow->{json}->{pipeline}->{job}
	= [
	   jsonjob ("Prepare input", $flow->{sol2bfq}),
	   jsonjob ("Map", $flow->{map}),
	   jsonjob ("Merge", $flow->{merge}),
	   jsonjob ("Assemble", $flow->{assemble}),
	   jsonjob ("Consensus", $flow->{cns2x}),
	   jsonjob ("indels", $flow->{indelsoa}),
	   ];
    writejson ("$workdir/$in", $flow->{json});
}

my @inputstream = sort keys %Flow;
printf (" %-10s" . (" %-38.38s" x scalar(@inputstream)) . "\n",
	"",
	@inputstream);
foreach my $function (qw(sol2bfq map merge assemble cns2x indelsoa))
{
    printf (" %-10s" . (" %-38s" x scalar(@inputstream)) . "\n",
	    $function,
	    map { id_and_output($Flow{$_}->{$function}) } @inputstream);
}

sub id_and_output
{
    my $job = shift;
    return "" if !$job;
    return $job->{id}."/".$job->{outputkey} if $job->{outputkey};
    my $steps = $job->{steps_done} + $job->{steps_running} + $job->{steps_todo};
    my $pct = $steps==0 ? "" : " (".int(100*$job->{steps_done}/$steps)."%)";
    return $job->{id}."/".$pct;
}

sub findjob
{
    my $want = shift;
    my $failed;
    my $queued;
    for (@Job)
    {
	if ($_->{revision} >= $want->{revision}->[0]
	    && ($_->{revision} <= $want->{revision}->[1] || !$want->{revision}->[1])
	    && $_->{mrfunction} eq $want->{mrfunction}
	    && $_->{knobs} eq $want->{knobs}
	    && $_->{inputkey} eq $want->{inputkey})
	{
	    $queued = $_ unless $queued || $_->{finishtime} || length ($_->{success});
	    $failed = $_ if !$failed && $_->{success} eq '0';
	    return $_ if $_->{outputkey};
	}
    }
    mention_failed_job ($failed) if !$queued && $failed;
    suggest_new_job ($want) if !$queued && !$want->{quiet} && (!$failed || $override{retryfailed});
    return $queued;
}

sub suggest_new_job
{
    my $want = shift;
    my $nodes = $want->{nodes} || 1;
    my $moreoptions = "";
    $moreoptions .= " stepspernode=".$want->{stepspernode} if $want->{stepspernode};
    my $revision = $want->{revision}->[1] || $revision_default;
    $revision = $want->{revision}->[0] if $revision < $want->{revision}->[0];
    my $knobs = $want->{knobs};
    $knobs =~ s{=(.*?)(\\n|$)}{='$1' }g;
    my $cmd = "wh job new nodes=$nodes photons=1 revision=$revision mrfunction='".$want->{mrfunction}."' inputkey='".$want->{inputkey}."'$moreoptions $knobs\n";
    print "$cmd\n";
    system "$cmd";
}

sub mention_failed_job
{
    my $job = shift;
    print "# suggest investigating job id=".$job->{id}." -- failed with frozentokey=".$job->{frozentokey}." metakey=".$job->{metakey}."\n";
}

sub makeknobs
{
    my $function = shift @_;
    my $knobs = "";
    foreach (sort @_)
    {
	my ($k) = /^(.*)=/;
	if (exists $override{"$function/$k"})
	{
	    $knobs .= $k."=".$override{"$function/$k"};
	}
	else
	{
	    $knobs .= $_;
	}
	$knobs .= "\\n";
    }
    $knobs =~ s/\\n$//s;
    return $knobs;
}

sub get_job_times
{
    my $job = shift;
    my $atwhichfreeze = shift;
    return {
	nodeseconds => 0,
	elapsed => 0,
	slot_seconds => 0,
	success_seconds => 0,
	failure_seconds => 0,
	} if !$job;
    my $frozen = $whc->job_follow_thawedfrom ($job);
    $frozen = $whc->job_stats ($frozen->{id});

    my $times = get_job_times ($frozen, $job->{thawedfromkey});

    $job = $whc->job_stats ($job->{id});
    my $frozentimes;
    if ($atwhichfreeze
	&& $job->{meta_stats}->{frozentokeys}
	&& ($frozentimes = $job->{meta_stats}->{frozentokeys}->{$atwhichfreeze}))
    {
	printf STDERR ("Adding stats from %d at t=%d: %d elapsed, %d success, %d failure, %d idle\n",
		       $job->{id},
		       $frozentimes->{frozentime},
		       $frozentimes->{elapsed},
		       $frozentimes->{success_seconds},
		       $frozentimes->{failure_seconds},
		       $frozentimes->{idle_seconds}) if $ENV{MTR_DEBUG};
	foreach (keys %$times)
	{
	    $times->{$_} += $frozentimes->{$_};
	}
    }
    else
    {
	if ($ENV{MTR_DEBUG})
	{
	    if ($atwhichfreeze)
	    {
		print STDERR "Adding stats from ".$job->{id}.", using entire job because frozentokey ".$atwhichfreeze." not found\n";
	    }
	    else
	    {
		print STDERR "Adding stats from ".$job->{id}."\n";
	    }
	}
	foreach (keys %$times)
	{
	    $times->{$_} += ($job->{meta_stats}->{$_} || $job->{$_});
	}
    }
    return $times;
}

sub jsonjob
{
    my $label = shift;
    my $job = shift;
    my $x = { "label" => $label };
    if ($job)
    {
	if ($job->{id}) { $x->{id} = $job->{id} }
	if ($job->{success}) { $x->{status} = "done" }
	elsif (defined $job->{success}) { $x->{status} = "fail" }
	elsif ($job->{finishtime}) { $x->{status} = "fail" }
	elsif ($job->{starttime}) { $x->{status} = "run" }
	elsif ($job->{submittime}) { $x->{status} = "queue" }
    }
    return $x;
}

sub writejson
{
    my $file = shift;
    my $json = shift;
    open F, "+>>$file.tmp";
    flock F, LOCK_EX or do { close F; return; };
    seek F, 0, 0;
    truncate F, 0;
    print F "{\n\"workflow\": ".sprintjson("", $json)."\n}\n";
    close F;
    rename "$file.tmp", "$file";
}

sub sprintjson
{
    my $indent = shift;
    my $ob = shift;
    $indent .= "    ";
    if (ref $ob eq "HASH") { return "{ " . join (",\n$indent", map { qq{ "$_": }.sprintjson($indent, $ob->{$_}) } keys %$ob) . " }"; }
    if (ref $ob eq "ARRAY") { return "[ " . join (",\n$indent", map { sprintjson($indent, $_) } @$ob) . " ]"; }
    if (ref $ob eq "SCALAR") { return qq{"} . $$ob . qq{"}; }
    return qq{"} . $ob . qq{"};
}

sub fork_downloader
{
    my $workfile = shift;
    my $child = fork();
    return if $child;
    return if !defined $child;
    exit 0 unless open L, "+>>", $workfile;
    exit 0 unless flock L, LOCK_EX;
    exit 1 unless open U, "<", "$workfile.isurl";
    my ($url) = <U>;
    $url =~ s/\'/\'\\\'\'/g;

    open F, "+>>", "$workfile.lock" or exit 1; # update mtime
    exit 0 unless flock F, LOCK_EX;
    print F $url;
    close F;

    my $key = `wget -O - '$url' 2>>$workfile.wget-log | whput -`;
    exit 1 if $?;
    symlink "$key", "$workfile.stored";
    rename "$workfile.lock", "$workfile.fetched";
    exit 0;
}


__END__

client          apache          downloader      status
----------------------------------------------------------------
submit url
                w umd5.isurl
                                                r umd5.isurl
                w umd5
                                w umd5
                                l umd5
                                r umd5.isurl
                                w umd5.lock
                                l umd5.lock
                                download
                                w umd5.stored@
                                w umd5.fetched
                                                r umd5.stored@
