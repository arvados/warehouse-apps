#!/usr/bin/perl

use strict;

my ($revision_default) = @ARGV or die "usage: $0 default-revision\n";

open STDIN, "wh job list |";
my %revision_min = ( expand => 1750,
		     bin_deg => 1751,
		     place_ref => 1872,
		     );

my %trialkey;
my %expand;
my %bin_deg;
my %place;
my %place_ref;
my %pileup;
my %Job;
my @Job;

my @jobs = <STDIN>;
for (@jobs)
{
    my %have;
    chomp;
    map { /(.*?)=(.*)/; $have{$1} = $2; } split (/, /);
    $Job{$have{id}} = \%have;
}
@Job = sort { $b->{id} <=> $a->{id} } values %Job;

for (@jobs)
{
    if (/mrfunction=awz-stream,/
	&& (my ($chr, $ploidy) = /knobs=CHROMOSOME=(chr[0-9XYM]+)\\nFUNCTION=mrs-awz-expand-degeneracies\\nINDIVIDUAL=0\\nOUTPUTNAME=reads.bin\\nPLOIDY=(\d)/)
	&& (my ($revision) = /revision=(\d+)/)
	&& (my ($id) = / id=(\d+)/)
	&& (my ($outputkey) = / outputkey=([^,]*)/))
    {
	next if $revision < $revision_min{expand};
	my $trialkey = $chr.".".$ploidy;
	next if $expand{$trialkey} && $expand{$trialkey}->{outputkey};
	$expand{$trialkey} = { id => $id,
			       outputkey => $outputkey };
	$trialkey{$outputkey} = $trialkey;
    }
}

for (@jobs)
{
    if ((my ($trial) = /mrfunction=awz-bin-degeneracies(\d),/)
	&& (my ($revision) = / revision=(\d+)/)
	&& (my ($id) = / id=([^,]*)/)
	&& (my ($inputkey) = / inputkey=([^,]*)/)
	&& (my ($outputkey) = / outputkey=([^,]*)/))
    {
	next if $revision < $revision_min{bin_deg};
	my $trialkey = $trialkey{$inputkey}.".".$trial;
	next if $bin_deg{$trialkey} && $bin_deg{$trialkey}->{outputkey};
	$bin_deg{$trialkey} = { id => $id,
				outputkey => $outputkey };
	$trialkey{$outputkey} = $trialkey;
    }
}

for (@jobs)
{
    if (/knobs=COLLISION_BITS=14\\nFUNCTION=mrs-awz-place\\nOUTPUTNAME=partition2?\.bin/
	&& (my ($revision) = /revision=(\d+)/)
	&& (my ($id) = / id=([^,]*)/)
	&& (my ($inputkey) = / inputkey=([^,]*)/)
	&& (my ($outputkey) = / outputkey=([^,]*)/))
    {
	next if $revision < $revision_min{place};
	my $trialkey = $trialkey{$inputkey};
	next if $place{$trialkey} && $place{$trialkey}->{outputkey};
	$place{$trialkey} = { id => $id,
			      outputkey => $outputkey };
	$trialkey{$outputkey} = $trialkey;
    }
}

for (@jobs)
{
    if (/knobs=CHUNKBITS=20\\nCUTBITS=26\\nFUNCTION=mrs-awz-place-ref\\nREFERENCE=7ae664a687be4b62c455eb5a0587fcce(\\nSWAP=1)?/
	&& (my ($revision) = /revision=(\d+)/)
	&& (my ($id) = / id=([^,]*)/)
	&& (my ($inputkey) = / inputkey=([^,]*)/)
	&& (my ($outputkey) = / outputkey=([^,]*)/))
    {
	next if $revision < $revision_min{place_ref};
	my $trialkey = $trialkey{$inputkey};
	next if $place_ref{$trialkey} && $place_ref{$trialkey}->{outputkey};
	$place_ref{$trialkey} = { id => $id,
				  outputkey => $outputkey };
	$trialkey{$outputkey} = $trialkey;
    }
}

for (@jobs)
{
    if (/knobs=CHUNKBITS=20\\nCHUNKNUM=235\\nCUTOFF=3\\nFILENAME=0:chr..?:0\\nMERGEKEYS=23fbf07d9f011619dfea3dc0e4d397e9/
	&& (my ($revision) = /revision=(\d+)/)
	&& (my ($id) = / id=([^,]*)/)
	&& (my ($inputkey) = / inputkey=([^,]*)/)
	&& (my ($outputkey) = / outputkey=([^,]*)/))
    {
	next if $revision < $revision_min{pileup};
	my $trialkey = $trialkey{$inputkey};
	next if $pileup{$trialkey} && $pileup{$trialkey}->{outputkey};
	$pileup{$trialkey} = { id => $id,
			       outputkey => $outputkey };
	$trialkey{$outputkey} = $trialkey;
    }
}

printf ("         %-32s %-32s %-32s %-32s %-32s\n",
	qw(expand-degeneracies bin-degeneracies place place-ref pileup));
foreach my $chrN (1..22, qw(X Y M))
{
    foreach my $ploidy (0, 1)
    {
	next if $chrN !~ /\d/ && $ploidy;

	my $expand;
	my @bin_deg;
	my @place;
	my @place_ref;
	$expand = findjob ( { mrfunction => "awz-stream",
			      revision => [1649, ],
			      inputkey => "f3864330c9d4315b8fac14fa7ad4b583",
			      knobs => "CHROMOSOME=chr$chrN\\nFUNCTION=mrs-awz-expand-degeneracies\\nINDIVIDUAL=0\\nOUTPUTNAME=reads.bin\\nPLOIDY=$ploidy",
			  } );
	if ($expand && $expand->{outputkey})
	{
	    foreach my $degen (1, 2)
	    {
		$bin_deg[$degen] = findjob ( { mrfunction => "awz-bin-degeneracies$degen",
					       revision => [1750, ],
					       inputkey => $expand->{outputkey},
					       knobs => ""
					       } );
		if ($bin_deg[$degen] && $bin_deg[$degen]->{outputkey})
		{
		    my $P = $degen==2 ? "2" : "";
		    $place[$degen] = findjob ( { mrfunction => "awz-stream",
						 revision => [1751, ],
						 inputkey => $bin_deg[$degen]->{outputkey},
						 knobs => "COLLISION_BITS=14\\nFUNCTION=mrs-awz-place\\nOUTPUTNAME=partition$P.bin",
					     } );
		}
		if ($place[$degen] && $place[$degen]->{outputkey})
		{
		    my $SWAP = $degen==2 ? "\\nSWAP=1" : "";
		    $place_ref[$degen] = findjob ( { mrfunction => "awz-files",
						     revision => [1872, ],
						     inputkey => $place[$degen]->{outputkey},
						     knobs => "CHUNKBITS=20\\nCUTBITS=26\\nFUNCTION=mrs-awz-place-ref\\nREFERENCE=7ae664a687be4b62c455eb5a0587fcce$SWAP",
						 } );
		}
	    }
	}
	if ($place_ref[1] && $place_ref[1]->{outputkey} &&
	    $place_ref[2] && $place_ref[2]->{outputkey})
	{
	    my $pileup = findjob ( { mrfunction => "awz-pileup",
				     revision => [ 1890, ],
				     inputkey => $place_ref[2]->{outputkey},
				     knobs => "CHUNKBITS=20\\nCHUNKNUM=235\\nCUTOFF=3\\nFILENAME=0:chr$chrN:0\\nMERGEKEYS=".$place_ref[1]->{outputkey},
				 } );
	}
    }
    foreach my $ploidy (0,1)
    {
	last if $ploidy && $chrN !~ /\d/;
	$_ = "chr$chrN.$ploidy";
	printf (" chr%-2s %1d %-32s %-32s %-32s %-32s %-32s\n",
		$chrN,
		$ploidy,
		$expand{$_}->{outputkey} || $expand{$_}->{id},
		$bin_deg{$_.".1"}->{outputkey} || $bin_deg{$_.".1"}->{id},
		$place{$_.".1"}->{outputkey} || $place{$_.".1"}->{id},
		$place_ref{$_.".1"}->{outputkey} || $place_ref{$_.".1"}->{id},
		$pileup{$_.".1"}->{outputkey} || $pileup{$_.".1"}->{id},
		);
	printf ("         %-32s %-32s %-32s %-32s %-32s\n",
		"",
		$bin_deg{$_.".2"}->{outputkey} || $bin_deg{$_.".2"}->{id},
		$place{$_.".2"}->{outputkey} || $place{$_.".2"}->{id},
		$place_ref{$_.".2"}->{outputkey} || $place_ref{$_.".2"}->{id},
		$pileup{$_.".2"}->{outputkey} || $pileup{$_.".2"}->{id},
		);
    }
}

sub findjob
{
    my $want = shift;
    my $queued;
    for (@Job)
    {
#	print $_->{mrfunction}." ".$_->{revision}." ".$_->{knobs}."\n";
	if ($_->{revision} >= $want->{revision}->[0]
	    && ($_->{revision} <= $want->{revision}->[1] || !$want->{revision}->[1])
	    && $_->{mrfunction} eq $want->{mrfunction}
	    && $_->{knobs} eq $want->{knobs}
	    && $_->{inputkey} eq $want->{inputkey})
	{
	    $queued = $_ unless $queued || $_->{finishtime} || length ($_->{success});
	    return $_ if $_->{outputkey};
	}
    }
    suggest_new_job ($want) if !$queued;
    return $queued;
}

sub suggest_new_job
{
    my $want = shift;
    my $revision = $want->{revision}->[1] || $revision_default;
    my $knobs = $want->{knobs};
    $knobs =~ s/=(.*?)(\\n|$)/='$1' /g;
    print "wh job new nodes=1 photons=1 revision=$revision mrfunction='".$want->{mrfunction}."' inputkey='".$want->{inputkey}."' $knobs\n";
}
