#!/usr/bin/perl

use strict;
use Digest::MD5 'md5_hex';
use HTTP::Request::Common;
use LWP::UserAgent;
use Fcntl ':flock';

my %defopts = qw(
		 batch     12
		 domain    images
		 class     single
		 positions ./position_list.dat
		 cycles    ./all_cycles.cfg
		 hybrid    000
		 lockfile  ./dssync.lock
		 localdir  .
		 quick     0
		 n         0
		 v         0
		 );
my %opts = %defopts;
while ($ARGV[0] =~ /^-/)
{
    if ($ARGV[0] =~ /^--(.*?)(=(.*))?$/)
    {
	$opts{$1} = defined($3) ? $3 : 1;
    }
    else
    {
	$ARGV[0] =~ /^-(.*)/;
	$opts{$1} = 1;
    }
    shift @ARGV;
}

if (@ARGV != 2)
{
    print STDERR <<EOF;
usage:
       $0 [options] keyprefix http://host/path/to/uploadscripts
options:
       --lockfile=/path/to/lockfile            default = $defopts{lockfile}
       --localdir=/path/to/images/raw          default = $defopts{localdir}
       --cycles=/path/to/all_cycles.cfg        default = $defopts{cycles}
       --positions=/path/to/position_list.dat  default = $defopts{positions}
       --hybrid=subdir,subdir,subdir           default = $defopts{hybrid}
       --include=subdir,subdir,subdir          default = $defopts{include}
       --domain=mogilefsdomain        default = $defopts{domain}
       --class=mogilefsclass          default = $defopts{class}
       --batch=maxfilesperrequest     default = $defopts{batch}
       --quick                        don't compare md5 of existing files
       -n                             don't really upload anything
       -v                             verbose
examples:
       $0 /tmp/RAW /foo_01/IMAGES/RAW http://tomc
EOF
;
    exit 1;
}

if (!open (LOCKFILE, ">>$opts{lockfile}")
    ||
    !flock (LOCKFILE, LOCK_EX | LOCK_NB))
{
    die "$0: Couldn't lock $opts{lockfile} -- exiting.\n";
}

my ($keyprefix, $remote) = @ARGV;
for ($keyprefix)
{
  s|/*$||;
}

if ($opts{v}) { warn "Getting manifest.\n"; }

my $manifestok;
my %storedmd5;
my $ua = LWP::UserAgent->new;
my $r = $ua->request(POST $remote."/manifest.php",
		     [ "keyprefix" => $keyprefix."/",
		       "domain" => $opts{domain},
		       "class" => $opts{class},
		       "quick" => $opts{quick} ]);
foreach (split (/\n/, $r->content))
{
    my ($md5, $key) = split;
    if ($md5 eq "--------------------------------") { $manifestok = 1; }
    else { $storedmd5{$key} = $md5; }
}
if (!$manifestok)
{
    die "Error retrieving manifest from $remote/manifest.php -- stopping.\n";
}

if ($opts{v}) { warn "Reading position list.\n"; }

open POSITIONS, "<$opts{positions}" or die "Can't open $opts{positions}: $!\n";
my @positions = <POSITIONS>;
close POSITIONS;
my $nframes = 0;
foreach (@positions)
{
    my ($frame_id, $x, $y, $w, $h) = split;
    if ($frame_id !~ /^\d+$/) { next; }
    ++$nframes;
}

if ($opts{v}) { warn "Reading cycle list.\n"; }

my %cycle;
open CYCLES_CFG, "<$opts{cycles}" or die "Can't open $opts{cycles}: $!\n";
my @cycles_cfg = <CYCLES_CFG>;
close CYCLES_CFG;
foreach (@cycles_cfg)
{
    s/\;.*//;
    my ($datasetname, $cycle_id, $wellnumber, $x, $x, @exposures) = split(",");
    $cycle{$cycle_id} = 0;
}

if ($opts{v}) { warn "Checking local files.\n"; }

my %hybrid;
foreach (split ($opts{hybrid}))
{
    $hybrid{$_} = 1;
}

my %include;
foreach (split ($opts{include}))
{
    $include{$_} = 1;
}

my $uploadtotal = 0;
my $queuesize = 0;
my @uploadqueue;
my @warn;
chdir ($opts{localdir}) or die "$0: Can't chdir to $opts{localdir}: $!\n";
opendir DIR, "."
    or die "$0: Can't read dir $opts{localdir}: $!\n";
foreach my $subdir (sort (readdir DIR))
{
    if (!-d $subdir) { next; }
    if ($subdir eq '.') { next; }
    if ($subdir eq '..') { next; }

    if ($subdir ne '999'
	&& !defined($hybrid{$subdir})
	&& !defined($cycle{$subdir}))
    {
	push (@warn, "Subdir \"$subdir\" is not listed in $opts{cycles}\n");
    }
    $cycle{$subdir} = 1;	# we found it

    opendir SUBDIR, $subdir
	or die "$0: Can't read dir $opts{localdir}/$subdir: $!\n";
    my @raw = grep (/\.raw$/i, readdir SUBDIR);
    if (@raw == 0)
    {
	rewinddir SUBDIR;
	@raw = grep (/\.tif$/i, readdir SUBDIR);
    }
    if (@raw == 0)
    {
	rewinddir SUBDIR;
	@raw = grep (/\.tif.gz$/i, readdir SUBDIR);
    }
    my $complete = (@raw == (($subdir eq '999' || defined($hybrid{$subdir}))
			     ? $nframes : $nframes * 4));
    if ($complete)
    {
	unshift (@warn, "Subdir \"$subdir\" is complete.\n");
    }
    else
    {
	my $nraw = scalar @raw;
	push (@warn, "Subdir \"$subdir\" is incomplete ($nraw images)\n");
    }
    if ($complete || $include{$subdir})
    {
	foreach my $file (@raw)
	{
	    $file = $subdir . "/" . $file;

	    my $key = $keyprefix . "/" . $file;

	    if ($opts{quick})
	    {
		if (exists($storedmd5{$key}))
		{
		    print STDERR "skip:    ".(" "x32)." $key\n";
		    next;
		}
		if ($opts{n})
		{
		    print STDERR "new:     ".(" "x32)." $key\n";
		    next;
		}
	    }

	    my $data;
	    do {
		local $/ = undef;
		open FILE, "<$file" or die "$0: Can't open $file: $!\n";
		$data = <FILE>;
		close FILE;
	    };

	    my $md5 = " " x 32;

	    if (!$opts{quick})
	    {
		$md5 = md5_hex($data);
		if ($storedmd5{$key} eq $md5)
		{
		    print STDERR "skip:    $md5 $key\n";
		    next;
		}
	    }

	    if (length($storedmd5{$key}) == 32)
	    {
		print STDERR "update:  $md5 $key\n";
	    }
	    else
	    {
		print STDERR "new:     $md5 $key\n";
	    }

	    upload($key, $file, $data) unless $opts{n};
	}
    }
}

upload() unless $opts{n};
print STDERR @warn;
print STDERR "$uploadtotal files uploaded.\n";

sub upload
{
    my ($key, $filename, $data) = @_;
    if (defined ($key))
    {
	my $n = $queuesize;
	if ($n == 0) { $n = ""; }
	push (@uploadqueue,
	      "upload$n" => [ undef, $key,
			      "Content-Type" => "application/binary",
			      "Content" => $data ]);
	++$queuesize;
	++$uploadtotal;
    }
    if ($queuesize >= $opts{batch} || (!defined($key) && $queuesize > 0))
    {
	warn "flush\n" if $opts{v} && $opts{batch} > 1;
	my $r = $ua->request
	    (POST $remote."/upload.cgi",
	     "Content-Type" => "form-data",
	     "Content"
	     => [ "domain" => $opts{domain},
		  "class" => $opts{class},
		  @uploadqueue ]);
	@uploadqueue = ();
	$queuesize = 0;
    }
}

# arch-tag: ae2f054a-fd2d-11db-9207-0015f2b17887
