#!/usr/bin/perl

eval 'exec /usr/bin/perl  -S $0 ${1+"$@"}'
    if 0; # not running under some shell

use strict;

use Warehouse;

my $commands = {
    "help" => \&help,
    "job freeze" => \&job_freeze,
    "job list" => \&job_list,
    "job new" => \&job_new,
    "job show" => \&job_show,
};

my $cmd = shift @ARGV;
while (!$commands->{$cmd})
{
    die "Unrecognized command.  Try \"$0 help\".\n" if !@ARGV;
    $cmd .= " ".(shift @ARGV);
}

my %opt;
map { $opt{$1} = $2 if /(.+?)=(.*)/s } @ARGV;

# Putting in a newline as a separator for knob keypairs is unwieldy on the
# command line. Instead, let's just accept a space as separator and turn it
# into a proper newline here, which is what the new_job warehouse function
# expects. If you need to include spaces in knobs, submit the knobs as
# separate opts like FOO="bar baz" instead of knobs="FOO=bar baz".
$opt{'knobs'} =~ s/ /\n/g;

my $whc;
$whc = new Warehouse ($opt{warehouse_name}
		      ? (warehouse_name => $opt{warehouse_name})
		      : ());

$commands->{$cmd}->();

sub help
{
    print qq{
wh help
wh job freeze id=ID [stop=1]
wh job list [id_min=ID] [id_max=ID]
wh job new nodes=N photons=N mrfunction=NAME revision=N inputkey=KEY \
           BARKNOB=foo BAZKNOB=baz
wh job new nodes=N photons=N thaw=ID

};
}

sub job_freeze
{
    if (!$whc->job_freeze (%opt))
    {
	warn ($whc->errstr . "\n");
    }
}

sub job_list
{
    if ($opt{id} && !$opt{id_min} && !$opt{id_max})
    {
	$opt{id_min} = $opt{id_max} = $opt{id};
    }
    my $joblist = $whc->job_list (%opt);
    if ($joblist)
    {
	foreach my $j (@$joblist)
	{
	    print join (", ", map { $_ . "=" . $j->{$_} } sort keys %$j) . "\n";
	}
    }
    else { warn ($whc->errstr . "\n"); }
}

sub job_show
{
    my $joblist = $whc->job_list (id_min => $opt{id}+0,
				  id_max => $opt{id}+0);
    if ($joblist)
    {
	foreach my $j (@$joblist)
	{
	    foreach (qw(inputkey revision mrfunction nprocs))
	    {
		my $arg = $j->{$_};
		$arg = "\"$arg\"" if $arg =~ /[^-\.\w=]/;
		print "$_=$arg ";
	    }
	    foreach (split (/\n/, freezeunquote ($j->{knobs})))
	    {
		$_ = "\"$_\"" if /[^-\.\w=]/;
		print "$_ ";
	    }
	    print "\n";
	}
    }
    else { warn ($whc->errstr . "\n"); }
}

sub job_new
{
    my @knobs = split (/\n/, $opt{'knobs'});
    foreach (sort keys %opt)
    {
	if (!/[a-z]/)		# treat uppercase wh opts as job knobs
	{
	    push @knobs, $_."=".$opt{$_};
	    delete $opt{$_};
	}
    }
    $opt{'knobs'} = join ("\n", @knobs);

    my $jobid = $whc->job_new (%opt);
    if ($jobid) { print ($jobid . "\n"); }
    else { warn ($whc->errstr . "\n"); }
}


sub freezequote
{
  my $s = shift;
  $s =~ s/\\/\\\\/g;
  $s =~ s/\n/\\n/g;
  return $s;
}


sub freezeunquote
{
  my $s = shift;
  $s =~ s{\\(.)}{$1 eq "n" ? "\n" : $1}ge;
  return $s;
}
