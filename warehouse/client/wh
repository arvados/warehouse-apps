#!/usr/bin/perl

eval 'exec /usr/bin/perl  -S $0 ${1+"$@"}'
    if 0; # not running under some shell

use strict;

use Warehouse;

my $commands = {
    "help" => \&help,
    "job freeze" => \&job_freeze,
    "job list" => \&job_list,
    "job new" => \&job_new,
    "job show" => \&job_show,
    "keep" => \&keep,
    "manifest list" => \&manifest_list,
    "manifest name" => \&manifest_name,
    "snap" => \&snap,
};

my $cmd = shift @ARGV;
while (!$commands->{$cmd})
{
    die "Unrecognized command.  Try \"$0 help\".\n" if !@ARGV;
    $cmd .= " ".(shift @ARGV);
}

my %opt;
map { $opt{$1} = $2 if /(.+?)=(.*)/s } @ARGV;

# Putting in a newline as a separator for knob keypairs is unwieldy on the
# command line. Instead, let's just accept a space as separator and turn it
# into a proper newline here, which is what the new_job warehouse function
# expects. If you need to include spaces in knobs, submit the knobs as
# separate opts like FOO="bar baz" instead of knobs="FOO=bar baz".
$opt{'knobs'} =~ s/ /\n/g if exists $opt{'knobs'};

my $whc;
$whc = new Warehouse ($opt{warehouse_name}
		      ? (warehouse_name => $opt{warehouse_name})
		      : ());

$commands->{$cmd}->();

sub help
{
    print qq{
wh help

wh job list [id_min=ID] [id_max=ID]
wh job show id=ID
wh job show id=ID outputkey
wh job show id=ID stepspernode mrfunction revision inputkey knobs ...

wh job new nodes=N photons=N mrfunction=NAME revision=N inputkey=KEY \
           BARKNOB=foo BAZKNOB=baz
wh job new nodes=N photons=N thaw=ID
wh job new nodes=N photons=N thawedfromkey=KEY

wh job freeze id=ID [stop=1]

wh manifest list [name=NAME] [key=KEY]
wh manifest name name=NAME [oldkey=KEY] newkey=KEY
wh manifest name name=NAME oldkey=KEY

wh keep key=KEY [nnodes=N]

wh snap

};
}

sub job_freeze
{
    my $ok = 1;
    my $oldfrozento;
    my $joblist;
    if (($joblist = $whc->job_list (id_min => $opt{id},
				    id_max => $opt{id}))
	&& $#$joblist == 0)
    {
	$oldfrozento = $joblist->[0]->{frozentokey};
    }
    if (!$whc->job_freeze (%opt))
    {
	$ok = 0;
	warn ($whc->errstr . "\n");
    }
    for (qw(0 1 2 2 3 3 4 4 5 5 5 10 10 10 10))
    {
	print STDERR "." if $_ >= 2;
	sleep $_;
	if (($joblist = $whc->job_list (id_min => $opt{id},
					id_max => $opt{id}))
	    && $#$joblist == 0)
	{
	    return 1 if !$joblist->[0]->{starttime}; # never started
	    my $newfrozento = $joblist->[0]->{frozentokey};
	    if ($newfrozento ne $oldfrozento)
	    {
		print STDERR "\n" if $_ >= 2;
		print "$newfrozento\n";
		return;
	    }
	}
	return if !$ok;
    }
    print STDERR " timed out waiting for new frozentokey to appear.\n";
    print STDERR "Previous frozentokey is $oldfrozento\n" if $oldfrozento;
}

sub job_list
{
    if ($opt{id} && !$opt{id_min} && !$opt{id_max})
    {
	$opt{id_min} = $opt{id_max} = $opt{id};
    }
    my $joblist = $whc->job_list (%opt);
    if ($joblist)
    {
	foreach my $j (@$joblist)
	{
	    print join (", ", map { $_ . "=" . $j->{$_} } sort keys %$j) . "\n";
	}
    }
    else { warn ($whc->errstr . "\n"); }
}

sub job_show
{
    my $joblist = $whc->job_list (id_min => $opt{id} || $opt{id_min},
				  id_max => $opt{id} || $opt{id_max});
    if ($joblist)
    {
	my @fieldlist = grep { !/=/ } @ARGV;
	for (0..$#fieldlist)
	{
	    if ($fieldlist[$_] eq "steps")
	    {
		splice (@fieldlist, $_, 1,
			qw(steps_done steps_running steps_todo));
		$_ += 2;
	    }
	}
	@fieldlist = qw(inputkey revision mrfunction stepspernode knobs)
	    if !@fieldlist;
      J:
	foreach my $j (@$joblist)
	{
	    for (keys %opt)
	    {
		if (!/^id(_min|_max|)$/)
		{
		    if (/^[A-Z]/)
		    {
			if ($j->{knobs} !~ /(^|\\n)\Q$_=$opt{$_}\E(\\n|$ )/x)
			{
			    next J;
			}
		    }
		    elsif ($opt{$_} ne $j->{$_})
		    {
			next J;
		    }
		}
	    }
	    my @out;
	    foreach (@fieldlist)
	    {
		if ($_ eq "knobs")
		{
		    foreach (split (/\n/, freezeunquote ($j->{knobs})))
		    {
			push @out, shellquote($_);
		    }
		}
		else
		{
		    my $arg = $j->{$_};
		    if (@fieldlist > 1)
		    {
			push @out, "$_=".shellquote($arg);
		    }
		    else
		    {
			push @out, $arg;
		    }
		}
	    }
	    print "@out\n";
	}
    }
    else { warn ($whc->errstr . "\n"); }
}

sub job_new
{
    my @knobs = split (/\n/, $opt{'knobs'});
    foreach (sort keys %opt)
    {
	if (!/[a-z]/)		# treat uppercase wh opts as job knobs
	{
	    push @knobs, $_."=".$opt{$_};
	    delete $opt{$_};
	}
    }
    $opt{'knobs'} = join ("\n", @knobs);

    my $jobid = $whc->job_new (%opt);
    if ($jobid) { print ($jobid . "\n"); }
    else { warn ($whc->errstr . "\n"); }
}

sub keep
{
    my $key = $opt{key};
    my $nnodes = $opt{nnodes} || 2;
    my $keepkey = $whc->store_in_keep (hash => $key,
				       nnodes => $nnodes);
    if ($keepkey) { print "$keepkey\n"; }
    else { warn ($whc->errstr . "\n"); }
}

sub manifest_list
{
    foreach my $keyname ($whc->list_manifests)
    {
	my ($key, $name, $keyid) = @$keyname;
	if ((!defined $opt{key} || $key eq $opt{key})
	    &&
	    (!defined $opt{name} || $name eq $opt{name}))
	{
	    print "$key $name $keyid\n";
	}
    }
}

sub manifest_name
{
    if ($whc->store_manifest_by_name ($opt{newkey}, $opt{oldkey}, $opt{name}))
    { print "$opt{newkey}\n"; }
    else { warn ($whc->errstr . "\n"); }
}

sub snap
{
    my %got;

    my $warehouse_name = $whc->{warehouse_name};
    $whc->write_start or die "Write failed: ".$whc->errstr;
    foreach my $keyname ($whc->list_manifests)
    {
	my ($key, $name) = @$keyname;
	my $needthis = 0;
	foreach (split (",", $key))
	{
	    if (!exists $got{$_}) { $needthis = $got{$_} = 1; }
	}
	next if !$needthis;

	$whc->write_data (". ");
	foreach (split (",", $key))
	{
	    if ($key !~ /\+K\d+\@\Q$warehouse_name\E\b/ && $opt{'keep'})
	    {
		$key .= "+K03\@$warehouse_name";
	    }
	    $whc->write_data ($key." ");
	}
	$whc->write_data ("0::$name\n");
    }

    my $joblist = $whc->job_list (id_min => $opt{id}+0,
				  id_max => $opt{id}+0);
    if ($joblist)
    {
	foreach my $j (@$joblist)
	{
	    foreach (qw(inputkey outputkey metakey frozentokey thawedfromkey))
	    {
		my $arg = $j->{$_};

		next if $arg !~ /^[0-9a-f]{32}/;

		my @snapblocks;

		my $needthis = 0;
		foreach (split (",", $arg))
		{
		    if ($opt{'keep'} && !/\+K\d+\@\Q$warehouse_name\E\b/)
		    {
			$_ .= "+K03\@$warehouse_name";
		    }
		    push @snapblocks, $_;
		    s/^([0-9a-f]{32})(\+.*)?$/$1/;
		    if (!exists $got{$_}) { $needthis = $got{$_} = 1; }
		}

		if ($needthis && @snapblocks)
		{
		    $arg =~ s/,/ /g;
		    $whc->write_data ("./".$j->{id}."/$_ @snapblocks 0::$_\n");
		}
	    }
	}
    }
    else { warn ("Nothing in job list: " . $whc->errstr . "\n"); }

    my @snapkey = $whc->write_finish or die "Write failed: ".$whc->errstr;
    my $snapkey = join (",", @snapkey);
    if ($opt{'keep'})
    {
	($snapkey) = $whc->store_in_keep (hash => $snapkey);
	$whc->store_manifest_by_name ($snapkey, undef, "/snap-".time)
    }
    print "$snapkey\n";
}


sub shellquote
{
    my $arg = shift;
    if ($arg =~ /[^-\.\w=\@\+]/)
    {
	$arg =~ s{[\"\`]}{\\$&}gx;
	$arg = "\"$arg\"";
    }
    $arg;
}


sub freezequote
{
  my $s = shift;
  $s =~ s/\\/\\\\/g;
  $s =~ s/\n/\\n/g;
  return $s;
}


sub freezeunquote
{
  my $s = shift;
  $s =~ s{\\(.)}{$1 eq "n" ? "\n" : $1}ge;
  return $s;
}
