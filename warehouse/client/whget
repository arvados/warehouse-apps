#!/usr/bin/perl

=head1 NAME

whget - get a data set or collection from the warehouse

=head1 SYNOPSIS

Fetch a file from a manifest:

       whget [options] locator/[subdir/]filename localfile
       whget [options] /name/[subdir/]filename localfile
       whget [options] warehouse:///locator/[subdir/]filename localfile
       whget [options] warehouse://warehousename/locator/[subdir/]filename localfile

Fetch a directory:

       whget [options] locator/[subdir/] localdir/
       whget [options] /name/[subdir/] localdir/

Fetch a directory tree:

       whget -r [options] locator/[subdir/] localdir/
       whget -r [options] /name/[subdir/] localdir/
       whget -r [options] /locator/[subdir/] -
       whget -r [options] /name/[subdir/] -

Fetch a raw manifest:

       whget [options] locator localdestfile
       whget [options] /name localdestfile
       whget [options] locator localdestdir/
       whget [options] /name localdestdir/

Options:

 -r    fetch subdir/*/*/files as well as subdir/files
 -n    don't write to local filesystem, just fetch data from warehouse
 -v    verbose: print md5sums of extracted files
 -vv   more verbose: info messages
 -vvv  more verbose: debug messages

Environment:

 WAREHOUSE  name of default warehouse (default = first in config file)

=head1 DESCRIPTION

B<whget> retrieves one data set or a hierarchy of data sets.

If the locator refers to a single data set, it is retrieved and stored.

If the locator refers to a manifest and ends with B</> all data sets within the top level of the manifest are retrieved.  If the B<-r> is also given, all data sets at any level are retrieved to the local filesystem.

A specific subdirectory within a manifest can be specified in the standard Unix subdirectory notation.

Data sets can be output to standard-output instead of being stored in the file system by specifying B<-> as the output name.

=cut

use strict;

use Warehouse;
use Digest::MD5;
use HTTP::Request::Common;
use LWP::UserAgent;

my %opt;
while ($ARGV[0] =~ /^-(?:-(\S+?)(=(.*))?|([^-]+))$/)
{
    if ($4) { map { $opt{$_}++ } split ("", $4); }
    else { $opt{$1} = defined ($2) ? $3 : 1; }
    shift @ARGV;
}
print STDERR map { "opt{$_} = $opt{$_}\n" } keys %opt
    if $opt{v} >= 3;

my $source = shift @ARGV or usage();
my $localbase = @ARGV ? shift @ARGV : "-";
@ARGV == 0 or usage();

if (-l $source && readlink ($source) =~ m|^[a-z]+://|)
{
    $source = readlink ($source);
}

if ($source =~ s|^warehouse://([^/]*)/||)
{
    $ENV{"WAREHOUSE"} = $1;
}

$source !~ m,/$,		# either you only want one file,
    or $localbase =~ s,/$,,	# or you specified a local directory/,
    or $localbase eq "-"	# or you want everything on stdout,
    or usage();			# or you're confused

my ($key_or_name, $path) = $source =~ m|^(/?[^/]*)(/.*)?|;

my $manifestkey;
my $manifestname;
if ($key_or_name =~ /^[0-9a-f]{32}(\+[^,\s]+)?(,[0-9a-f]{32}(\+[^,\s]+)*)*$/)
{
    $manifestkey = $key_or_name;
}
else
{
    $manifestname = $key_or_name;
}

my $justrawmanifest = 1;
my ($wantsubdir, $wantfile);
if ($path =~ m|^(.*)/([^/]*)$|)
{
    $wantsubdir = $1;
    $wantfile = $2;
    $justrawmanifest = 0;
}



my $whc = new Warehouse ("mogilefs_trackers" => $opt{"mogilefs-trackers"},
			 "debug_mogilefs_paths" => ($opt{v} >= 3),
			 );
if (!defined $manifestkey)
{
    $manifestkey = $whc->fetch_manifest_key_by_name ($manifestname)
	or die "Could not get key for '$manifestname': ".$whc->errstr;
}

# $manifestkey is a comma-separated list of hashes of the blocks that
# make up the manifest.

my @manifesthash = split (",", $manifestkey);
my $manifest = "";
while (!length $manifest && @manifesthash)
{
    $manifest = $whc->fetch_block ($manifesthash[0]);
    die "fetch_block($manifesthash[0]) failed" if !defined $manifest;
    shift @manifesthash;
}

if ($justrawmanifest)
{
    if (-d $localbase)
    {
	$localbase =~ s,/$,,;
	if (defined $manifestname)
	{
	    $localbase .= "/".$manifestname;
	}
	else
	{
	    $localbase .= "/".$manifestkey;
	}
    }
    my $localfile = $localbase;
    if ($localfile eq "-")
    {
	$localfile = "&STDOUT";
    }
    if (!$opt{n} && !open M, ">$localfile")
    {
	die "Can't open $localfile: $!";
    }
    my $ctx;
    $ctx = Digest::MD5->new if $opt{v};
    while (1)
    {
	$ctx->add ($manifest) if $opt{v};
	print M $manifest unless $opt{n};
	last if !@manifesthash;

	defined ($manifest = $whc->fetch_block ($manifesthash[0]))
	    or die "fetch_block($manifesthash[0]) failed";
	shift @manifesthash;
    }
    $opt{n} or close M or die "Error writing $localbase: $!";
    !$opt{v} or print STDERR $ctx->hexdigest."  $localbase\n";
    exit 0;
}

# $manifest is the current block; @manifesthash is a list of hashes of
# subsequent blocks.

while (0 < length $manifest)
{
    $manifest =~ s/^([^\n]*)\n//
	or die "no newline at end of manifest";
    my @subdir = split (" ", $1);
    my $subdir_name = shift @subdir;

    $subdir_name =~ s/^\.//
	or die "subdir name '$subdir_name' does not start with period";
    if ($subdir_name eq $wantsubdir ||
	($opt{r} &&
	 $wantfile eq "" &&
	 substr($subdir_name, 0, 1 + length $wantsubdir) eq $wantsubdir."/"))
    {
	my $localsubdir = substr ($subdir_name, length $wantsubdir);

	print STDERR "consider: .$subdir_name as $localbase$localsubdir\n"
	    if $opt{v} >= 3;

	my @hash;
	while (@subdir)
	{
	    if ($subdir[0] =~ /^-(\d+)$/)
	    {
		push @hash, splice @subdir, 0, 2;
	    }
	    elsif ($subdir[0] =~ /^[0-9a-f]{32}([-\+].*)?$/)
	    {
		push @hash, shift @subdir;
	    }
	    else
	    {
		last;
	    }
	}

	my $data = "";
	my $streampos = 0;

	foreach (@subdir)
	{
	    my ($pos, $size, $name) = split (":", $_, 3);
	    if ($wantfile eq "" || $wantfile eq $name)
	    {
		print STDERR "want:  $pos $size $name\n"
		    if $opt{v} >= 3;

		# read data, or skip blocks, until we are at $streampos==$pos

		my $sizehint;
		while (@hash &&
                       ($hash[0] =~ /^([0-9a-f]{32})?.*?\+GS()(\d+)/ ||
                        $hash[0] =~ /^([0-9a-f]{32})?([-\+])(\d+)/) &&
		       $pos >= ($streampos
				+ ($sizehint = ($2 eq '-'
						? $Warehouse::blocksize - $3
						: $3))
				+ length $data))
		{
		    shift @hash if !defined $1;
		    print STDERR "skip $hash[0]\n"
			if $opt{v} >= 3;
		    shift @hash;

		    $streampos += length $data;
		    $streampos += $sizehint;
		    $data = "";
		}
		while ($pos > $streampos + length $data
		       && @hash)
		{
		    # skip "blockshortness" token
		    shift @hash if $hash[0] =~ /^-\d+$/;

		    $streampos += length $data;
		    print STDERR "fetch $hash[0]\n"
			if $opt{v} >= 3;
		    $data = $whc->fetch_block (shift @hash)
			or die "fetch_block failed";

		    # this loop should only run once if blockshortness
		    # tokens are present
		}
		if ($pos > $streampos
		    && $pos <= $streampos + length $data)
		{
		    substr ($data, 0, $pos - $streampos) = "";
		    $streampos = $pos;
		}
		if ($pos != $streampos)
		{
		    die "Internal error: sought $pos but at $streampos";
		}

		# write bytes from $data, and fetch subsequent blocks,
		# until $size bytes have been written

		my $localfile = $localbase.$localsubdir;
		$localfile .= "/".$name if $wantfile eq "";
		$localfile = "-" if $localbase eq "-";

		make_parent_dirs ($localfile)
		    unless $opt{n};

		print STDERR "write to: $localfile\n"
		    if $opt{v} >= 3;
		open F, ">$localfile"
		    or die "Can't open $localfile for writing: $!"
		    unless $opt{n};

		my $ctx;
		$ctx = Digest::MD5->new
		    if $opt{v};
		while ($pos + $size > $streampos + length $data)
		{
		    $ctx->add ($data)
			if $opt{v};
		    print F $data
			or die "Error writing to $localfile: $!"
			unless $opt{n};

		    $streampos += length $data;

		    # skip "blockshortness" token
		    shift @hash if $hash[0] =~ /^-\d+$/;

		    print STDERR "fetch $hash[0]\n"
			if $opt{v} >= 3;
		    my $nexthash = shift @hash;
		    $data = $whc->fetch_block ($nexthash)
			or die "fetch_block($nexthash) failed";
		}

		$ctx->add (substr ($data, 0, $pos + $size - $streampos))
		    if $opt{v};
		print F substr ($data, 0, $pos + $size - $streampos)
		    or die "Error writing to $localfile: $!"
		    unless $opt{n};
		close F
		    or die "Error writing to $localfile: $!"
		    unless $opt{n};

		substr ($data, 0, $pos + $size - $streampos) = "";
		$streampos = $pos + $size;

		do {
		    my $md5hex = $ctx->hexdigest;
		    print STDERR "$md5hex  $localfile\n";
		} if $opt{v};
	    }
	}
    }

    if (@manifesthash &&
	$Warehouse::blocksize > 2 * length $manifest)
    {
	my $nextblock = $whc->fetch_block (shift @manifesthash)
	    or die "fetch_block failed";
	$manifest .= $nextblock;
    }
}

print STDERR $whc->iostats
    if $opt{v};


sub make_parent_dirs
{
    my $path = shift @_;
    return unless $path =~ s|/[^/]+$||;
    return if -d $path;
    make_parent_dirs ($path);
    mkdir $path;
}


sub usage
{
    my ($me) = $0 =~ m|([^/]+)$|;
    die <<EOF
Fetch a file from a manifest:
       $me [options] key/[subdir/]filename localfile
       $me [options] /name/[subdir/]filename localfile
       $me [options] warehouse:///key/[subdir/]filename localfile
       $me [options] warehouse://warehousename/key/[subdir/]filename localfile
Fetch a directory:
       $me [options] key/[subdir/] localdir/
       $me [options] /name/[subdir/] localdir/
Fetch a directory tree:
       $me -r [options] key/[subdir/] localdir/
       $me -r [options] /name/[subdir/] localdir/
       $me -r [options] /key/[subdir/] -
       $me -r [options] /name/[subdir/] -
Fetch a raw manifest:
       $me [options] key localdestfile
       $me [options] /name localdestfile
       $me [options] key localdestdir/
       $me [options] /name localdestdir/
options:
 -r    fetch subdir/*/*/files as well as subdir/files
 -n    don't write to local filesystem, just fetch data from warehouse
 -v    verbose: print md5sums of extracted files
 -vv   more verbose: info messages
 -vvv  more verbose: debug messages
environment:
 WAREHOUSE  name of default warehouse (default = first in config file)
EOF
;
}
