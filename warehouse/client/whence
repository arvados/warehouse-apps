#!/usr/bin/perl

use strict;
use Warehouse;
use Warehouse::Stream;

my %opt;
while ($ARGV[0] =~ /^--(\S+)(?:=(.*))?/)
{
    $opt{$1} = defined($2) ? $2 : 1;
    shift @ARGV;
}

if (@ARGV != 1)
{
    die <<EOF;
usage: whence [options] {key|jobid}[\@warehouse]
options:
       --skip-thawed     don\'t follow freeze/thaw cycles
       --node-seconds    show total #nodes * seconds allocated to each job
       --slots           show number of slots (maximum concurrent job steps)
       --slot-seconds    show number of slots * job duration
       --failure-seconds show total slot seconds for failed job steps
       --success-seconds show total slot seconds for successful job steps
       --idle-seconds    show total slot seconds not accounted for by job steps
EOF
}

my ($key, $warehouse_name) = split (/\@/, shift @ARGV);
$warehouse_name = $Warehouse::warehouses->[0]->{name}
    if !defined $warehouse_name;

my $whc = new Warehouse (warehouse_name => $warehouse_name);
my $joblist = $whc->job_list;
my %output_to_job;
my %id_to_job;
for my $job (@$joblist)
{
    $output_to_job{$job->{outputkey}} = $job
	unless $job->{outputkey} eq $job->{inputkey};
    $id_to_job{$job->{id}} = $job;
}

my $targetjob;
$targetjob = $id_to_job{$key} if exists $id_to_job{$key};
$targetjob = $output_to_job{$key} if exists $output_to_job{$key};
die "Didn't find a job whose id or output is $key\n" if !defined $targetjob;

while (defined $targetjob)
{
    printf "#%d\@%s\n", $targetjob->{id}, $warehouse_name;
    print_times ($targetjob);
    printf "  mrfunction = %s r%d\n", $targetjob->{mrfunction}, $targetjob->{revision};

    if (($opt{"skip-thawed"} && $targetjob->{revision} != -1)
	|| !$targetjob->{thawedfromkey})
    {
	printf "  output = %s\n", $targetjob->{outputkey};
	printf "  input = %s\n", $targetjob->{inputkey};
	map { printf "  %s\n", $_ } split (/\\n/, $targetjob->{knobs});
	print "\n";

	$output_to_job{$targetjob->{outputkey}} = "loop";

	last if $targetjob->{inputkey} !~ /\S/;

	$targetjob = $output_to_job{$targetjob->{inputkey}};
	if ($targetjob eq "loop")
	{
	    warn "Cycle detected; stopping.\n";
	    last;
	}
    }
    else
    {
	printf "  output = %s\n", $targetjob->{outputkey};
	printf ("  thawedfromkey = %s\n", $targetjob->{thawedfromkey});

	my $thawhash = $targetjob->{thawedfromkey};
	my ($firstblock) = $thawhash =~ /^([0-9a-f]{32})/;
	my $thawed = $whc->fetch_block ($firstblock,
					{ verify => 0, length => 500 })
	    or die "fetch_block($firstblock) failed";
	$thawed =~ /^job (\d+)\n/
	    or die "could not parse thawedfromkey $thawhash";
	($1 < $targetjob->{id})
	    or die "thawedfromkey $thawhash claims to be from job $1, which was not even submitted yet when job ".$targetjob->{id}." was submitted.\n";
	($targetjob = $id_to_job{$1})
	    or die "couldn't find job $1 in job list";

	my $verified = 0;
	my $metastream = new Warehouse::Stream
	    (whc => $whc,
	     hash => [split (/,/, $targetjob->{metakey})]);
	$metastream->rewind;
	while (my $dataref = $metastream->read_until (undef, "\n"))
	{
	    if ($$dataref =~ /^\S+ \d+ \d+  frozento ?key is (\S+)/
		&& $1 eq $thawhash)
	    {
		$verified = 1;
		last;
	    }
	}
	if (!$verified)
	{
	    warn "WARNING: thawedfromkey $thawhash does not appear in meta stream of job ".$targetjob->{id}." -- continuing anyway.\n";
	}
    }
}

sub print_times
{
    my $job = shift;
    my $elapsed;
    my $nodeseconds;
    if (($opt{"node-seconds"} || $opt{"slot-seconds"})
	&& $job->{finishtime_s} && $job->{starttime_s})
    {
	my $nnodes = $job->{nnodes};
	$elapsed = $job->{finishtime_s} - $job->{starttime_s};
	$nodeseconds = $elapsed * $nnodes;
	printf ("  --node-seconds = %d = %d nodes * %d seconds\n",
		$nodeseconds, $nnodes, $elapsed) if $opt{"node-seconds"};
    }
    if (($opt{"failure-seconds"} || $opt{"success-seconds"} || $opt{"slots"} || $opt{"slot-seconds"})
	&& $job->{metakey})
    {
	my $failure_seconds = 0;
	my $success_seconds = 0;
	my $allocation_slots = 0;
	my $s = new Warehouse::Stream (whc => $whc,
				       hash => [split (",", $job->{metakey})]);
	$s->rewind();
	while (my $dataref = $s->read_until (undef, "\n"))
	{
	    if ($$dataref =~ /^\S+ \d+ \d+ \d+ (success|failure) in (\d+) seconds\n/)
	    {
		$failure_seconds += $2 if $1 eq "failure";
		$success_seconds += $2 if $1 eq "success";
	    }
	    elsif ($$dataref =~ /^\S+ \d+ \d+  node \S+ - (\d+) slots\n/)
	    {
		$allocation_slots += $1;
	    }
	}
	my $slot_seconds = $allocation_slots * $elapsed;

	printf ("  --slots = %d\n", $allocation_slots)
	    if ($opt{"slots"});
	printf ("  --slot-seconds = %d\n", $slot_seconds)
	    if ($opt{"slots"} && defined $elapsed);
	printf ("  --failure-seconds = %d%s\n", $failure_seconds, fmt_percent_of ($failure_seconds, $slot_seconds))
	    if ($opt{"failure-seconds"});
	printf ("  --success-seconds = %d%s\n", $success_seconds, fmt_percent_of ($success_seconds, $slot_seconds))
	    if ($opt{"success-seconds"});
	printf ("  --idle-seconds = %d%s\n", $slot_seconds - $failure_seconds - $success_seconds,
		fmt_percent_of ($slot_seconds - $failure_seconds - $success_seconds, $slot_seconds))
	    if ($opt{"idle-seconds"});
    }
}

sub fmt_percent_of
{
    my ($a, $b) = @_;
    return "" if !$b;
    my $p = 100 * $a / $b;
    if ($p < 1) { return sprintf (" (%.2f%%)", $p); }
    if ($p < 10) { return sprintf (" (%.1f%%)", $p); }
    return sprintf (" (%d%%)", $p);
}
