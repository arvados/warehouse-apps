#!/usr/bin/perl

use strict;
use Warehouse;
use Warehouse::Stream;

my %opt;
while ($ARGV[0] =~ /^--(\S+)(?:=(.*))?/)
{
    $opt{$1} = defined($2) ? $2 : 1;
    shift @ARGV;
}

if (@ARGV != 1)
{
    die <<EOF;
usage: whence [options] {key|jobid}[\@warehouse]
options:
       --skip-thawed     don\'t follow freeze/thaw cycles
       --node-seconds    show total #nodes * seconds allocated to each job
       --slot-seconds    show total slot seconds for all job steps
       --success-seconds show total slot seconds for successful job steps
EOF
}

my ($key, $warehouse_name) = split (/\@/, shift @ARGV);
$warehouse_name = $Warehouse::warehouses->[0]->{name}
    if !defined $warehouse_name;

my $whc = new Warehouse (warehouse_name => $warehouse_name);
my $joblist = $whc->job_list;
my %output_to_job;
my %id_to_job;
for my $job (@$joblist)
{
    $output_to_job{$job->{outputkey}} = $job
	unless $job->{outputkey} eq $job->{inputkey};
    $id_to_job{$job->{id}} = $job;
}

my $targetjob;
$targetjob = $id_to_job{$key} if exists $id_to_job{$key};
$targetjob = $output_to_job{$key} if exists $output_to_job{$key};
die "Didn't find a job whose id or output is $key\n" if !defined $targetjob;

while (defined $targetjob)
{
    printf "#%d\@%s\n", $targetjob->{id}, $warehouse_name;
    print_times ($targetjob);
    printf "  mrfunction = %s r%d\n", $targetjob->{mrfunction}, $targetjob->{revision};

    if (($opt{"skip-thawed"} && $targetjob->{revision} != -1)
	|| !$targetjob->{thawedfromkey})
    {
	printf "  output = %s\n", $targetjob->{outputkey};
	printf "  input = %s\n", $targetjob->{inputkey};
	map { printf "  %s\n", $_ } split (/\\n/, $targetjob->{knobs});
	print "\n";

	$output_to_job{$targetjob->{outputkey}} = "loop";

	last if $targetjob->{inputkey} !~ /\S/;

	$targetjob = $output_to_job{$targetjob->{inputkey}};
	if ($targetjob eq "loop")
	{
	    warn "Cycle detected; stopping.\n";
	    last;
	}
    }
    else
    {
	printf "  output = %s\n", $targetjob->{outputkey};
	printf ("  thawedfromkey = %s\n", $targetjob->{thawedfromkey});

	my $thawhash = $targetjob->{thawedfromkey};
	my $thawed = $whc->fetch_block ($thawhash,
					{ verify => 0, length => 500 })
	    or die "fetch_block($thawhash) failed";
	$thawed =~ /^job (\d+)\n/
	    or die "could not parse thawedfromkey $thawhash";
	($1 < $targetjob->{id})
	    or die "thawedfromkey $thawhash claims to be from job $1, which was not even submitted yet when job ".$targetjob->{id}." was submitted.\n";
	($targetjob = $id_to_job{$1})
	    or die "couldn't find job $1 in job list";

	my $verified = 0;
	my $metastream = new Warehouse::Stream
	    (whc => $whc,
	     hash => [split (/,/, $targetjob->{metakey})]);
	$metastream->rewind;
	while (my $dataref = $metastream->read_until (undef, "\n"))
	{
	    if ($$dataref =~ /^\S+ \d+ \d+  frozento ?key is (\S+)/
		&& $1 eq $thawhash)
	    {
		$verified = 1;
		last;
	    }
	}
	if (!$verified)
	{
	    warn "WARNING: thawedfromkey $thawhash does not appear in meta stream of job ".$targetjob->{id}." -- continuing anyway.\n";
	}
    }
}

sub print_times
{
    my $job = shift;
    if ($opt{"node-seconds"} && $job->{finishtime_s} && $job->{starttime_s})
    {
	my $nnodes = $job->{nnodes};
	my $elapsed = $job->{finishtime_s} - $job->{starttime_s};
	my $nodeseconds = $elapsed * $nnodes;
	printf ("  --node-seconds = %d = %d nodes * %d seconds\n",
		$nodeseconds, $nnodes, $elapsed);
    }
}
