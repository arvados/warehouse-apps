#!/usr/bin/perl

use strict;
use Warehouse;
use Warehouse::Stream;

my %opt;
while ($ARGV[0] =~ /^--(\S+)(?:=(.*))?/)
{
    $opt{$1} = defined($2) ? $2 : 1;
    shift @ARGV;
}

if (@ARGV != 1)
{
    die <<EOF;
usage: whence [options] {key|jobid}[\@warehouse]
options:
       --skip-thawed     don\'t follow freeze/thaw cycles
       --node-seconds    show total #nodes * seconds allocated to each job
       --slots           show number of slots (maximum concurrent job steps)
       --slot-seconds    show number of slots * job duration
       --failure-seconds show total slot seconds for failed job steps
       --success-seconds show total slot seconds for successful job steps
       --idle-seconds    show total slot seconds not accounted for by job steps
EOF
}

my $key = shift @ARGV;

my %opts;
$opts{warehouse_name} = $1 if $key =~ s/\@(.+)//;

my $whc = new Warehouse (%opts);
my $joblist = $whc->job_list;
my %did;
my %id_to_job;
for my $job (@$joblist)
{
    $id_to_job{$job->{id}} = $job;
}

my $targetjob;
$targetjob = $whc->job_follow_input ( { inputkey => $key } ) || $id_to_job{$key};
die "Didn't find a job whose id or output is $key\n" if !defined $targetjob;

while (defined $targetjob)
{
    if ($did{$targetjob->{id}})
    {
	warn "Cycle detected; stopping.\n";
	last;
    }
    $did{$targetjob->{id}} = 1;

    printf "#%d\@%s\n", $targetjob->{id}, $whc->{warehouse_name};
    print_times ($whc->job_stats ($targetjob->{id}));
    printf "  mrfunction = %s r%d\n", $targetjob->{mrfunction}, $targetjob->{revision};

    if (($opt{"skip-thawed"} && $targetjob->{revision} != -1)
	|| !$targetjob->{thawedfromkey})
    {
	printf "  output = %s\n", $targetjob->{outputkey};
	printf "  input = %s\n", $targetjob->{inputkey};
	map { printf "  %s\n", $_ } split (/\\n/, $targetjob->{knobs});
	print "\n";

	last if $targetjob->{inputkey} !~ /\S/;
	$targetjob = $whc->job_follow_input ($targetjob);
    }
    else
    {
	printf "  output = %s\n", $targetjob->{outputkey};
	printf ("  thawedfromkey = %s\n", $targetjob->{thawedfromkey});
	$targetjob = $whc->job_follow_thawedfrom ($targetjob);
    }
}

sub print_times
{
    my $job = shift;
    my $metastats = $job->{meta_stats};
    if ($job)
    {
	printf ("  --node-seconds = %d = %d nodes * %d seconds\n",
		$job->{nodeseconds},
		$job->{nnodes},
		$job->{elapsed});
	printf ("  --slot-seconds = %d = %d slots * %d seconds\n",
		$metastats->{slot_seconds},
		$metastats->{slots},
		$job->{elapsed});
	foreach (qw(success failure idle))
	{
	    printf ("  --$_-seconds = %d%s\n",
		    $metastats->{$_."_seconds"},
		    $metastats->{$_."_percent"}
		    ? " = ".$metastats->{$_."_percent"}."%" : "");
	}
    }
}
